<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Tutorials-rsses on Light Java - The fastest Java API Framework</title>
    <link>https://networknt.github.io/light-java/tutorials/index.xml</link>
    <description>Recent content in Tutorials-rsses on Light Java - The fastest Java API Framework</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>Released under the MIT license</copyright>
    <lastBuildDate>Wed, 15 Feb 2017 09:26:58 -0500</lastBuildDate>
    <atom:link href="https://networknt.github.io/light-java/tutorials/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Cross-Origin Resource Sharing</title>
      <link>https://networknt.github.io/light-java/tutorials/cors/</link>
      <pubDate>Wed, 15 Feb 2017 09:26:58 -0500</pubDate>
      
      <guid>https://networknt.github.io/light-java/tutorials/cors/</guid>
      <description>&lt;p&gt;For some of the APIs/services, the endpoints will be accessed from a Single Page
Application(React/Vue/Angular) served from another domain. In this case, the API
server needs to handle the pre-flight OPTIONS request to enable CORS.&lt;/p&gt;

&lt;p&gt;As CORS only used in above scenario, the handler is not wired in by default in
swagger-codegen.&lt;/p&gt;

&lt;p&gt;If you want to limit only several domains for CORS, you also need to create cors.json
in config folder.&lt;/p&gt;

&lt;p&gt;And here is an example of cors.json&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
  &amp;quot;description&amp;quot;: &amp;quot;Cors Http Handler&amp;quot;,
  &amp;quot;enabled&amp;quot;: true,
  &amp;quot;allowedOrigins&amp;quot;: [
    &amp;quot;http://localhost&amp;quot;
  ]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To enable CORS support, you need to add cors module in pom.xml, you need to update
pom.xml to add a dependency.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;com.networknt&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;cors&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;${version.light-java}&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Update com.networknt.handler.MiddlewareHandler in src/main/resources/META-INF/services
folder to plug cors handler into the middleware chain. Note that cors handler is in front
of swagger so that pre-flight OPTIONS request will be returned before swagger validation
is done as OPTIONS methods are not defined in swagger specifitions.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# This file is generated and should not be changed unless you want to plug in more handlers into the handler chain
# for cross cutting concerns. In most cases, you should replace some of the default handlers with your own implementation
# Please note: the sequence of these handlers are very important.

#Validator Validate request based on swagger specification (depending on Swagger and Body)
com.networknt.validator.ValidatorHandler
#Sanitizer Encode cross site scripting
com.networknt.sanitizer.SanitizerHandler
#SimpleAudit Log important info about the request into audit log
com.networknt.audit.AuditHandler
#Body Parse body based on content type in the header.
com.networknt.body.BodyHandler
#Security JWT token verification and scope verification (depending on SwaggerHandler)
com.networknt.security.JwtVerifyHandler
#Swagger Parsing swagger specification based on request uri and method.
com.networknt.swagger.SwaggerHandler
#Cors handler to handler post/put pre-flight
com.networknt.cors.CorsHttpHandler
#Correlation Create correlationId if it doesn&#39;t exist in the request header and put it into the request header
com.networknt.correlation.CorrelationHandler
#Traceability Put traceabilityId into response header from request header if it exists
com.networknt.traceability.TraceabilityHandler
#Metrics In order to calculate response time accurately, this needs to be the second.
com.networknt.metrics.MetricsHandler
#Exception Global exception handler that needs to be called first.
com.networknt.exception.ExceptionHandler
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now let&amp;rsquo;s start the server&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd ~/networknt/light-java-example/cors
mvn clean install exec:exec
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Test the pre-flight OPTIONS.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;curl -H &amp;quot;Origin: http://example.com&amp;quot; -H &amp;quot;Access-Control-Request-Method: POST&amp;quot;  -H &amp;quot;Access-Control-Request-Headers: X-Requested-With&amp;quot;  -X OPTIONS --verbose http://localhost:8080/v1/postData
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And the result&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;*   Trying 127.0.0.1...
* Connected to localhost (127.0.0.1) port 8080 (#0)
&amp;gt; OPTIONS /v1/postData HTTP/1.1
&amp;gt; Host: localhost:8080
&amp;gt; User-Agent: curl/7.43.0
&amp;gt; Accept: */*
&amp;gt; Origin: http://example.com
&amp;gt; Access-Control-Request-Method: POST
&amp;gt; Access-Control-Request-Headers: X-Requested-With
&amp;gt; 
&amp;lt; HTTP/1.1 200 OK
&amp;lt; Access-Control-Allow-Headers: X-Requested-With
&amp;lt; Server: Light
&amp;lt; Access-Control-Allow-Credentials: true
&amp;lt; Content-Length: 0
&amp;lt; Access-Control-Allow-Methods: POST
&amp;lt; Access-Control-Max-Age: 3600
&amp;lt; Date: Wed, 15 Feb 2017 13:37:29 GMT
&amp;lt; 
* Connection #0 to host localhost left intact

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The source code for the cors example can be found at&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/networknt/light-java-example/tree/master/cors&#34;&gt;https://github.com/networknt/light-java-example/tree/master/cors&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Registry and Discovery</title>
      <link>https://networknt.github.io/light-java/tutorials/discovery/</link>
      <pubDate>Fri, 27 Jan 2017 20:57:14 -0500</pubDate>
      
      <guid>https://networknt.github.io/light-java/tutorials/discovery/</guid>
      <description>

&lt;h1 id=&#34;introduction&#34;&gt;Introduction&lt;/h1&gt;

&lt;p&gt;This is a tutorial to show you how to use service registry and discovery
for microservices. We are going to use api_a, api_b, api_c and api_d as
our examples. To simply the tutorial, I am going to disable the security
all the time.&lt;/p&gt;

&lt;p&gt;The specifications for above APIs can be found at
&lt;a href=&#34;https://github.com/networknt/swagger&#34;&gt;https://github.com/networknt/swagger&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;preparation&#34;&gt;Preparation&lt;/h1&gt;

&lt;p&gt;In order to follow the steps below, please make sure you have the same
working environment.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;A computer with MacOS or Linux (Windows should work but I never tried)&lt;/li&gt;
&lt;li&gt;Install git&lt;/li&gt;
&lt;li&gt;Install Docker&lt;/li&gt;
&lt;li&gt;Install JDK 8 and Maven&lt;/li&gt;
&lt;li&gt;Install Java IDE (Intellij IDEA Community Edition is recommended)&lt;/li&gt;
&lt;li&gt;Create a working directory under your user directory called networknt.&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;cd ~
mkdir networknt
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;clone-the-specifications&#34;&gt;Clone the specifications&lt;/h1&gt;

&lt;p&gt;In order to generate the initial projects, we need to call swagger-codegen
and we need the specifications for these services.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd ~/networknt
git clone git@github.com:networknt/swagger.git
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In this repo, you have a generate.sh in the root folder to use docker
container of swagger-codegen to generate the code and there are api_a,
api_b, api_c and api_d folder for swagger.yaml files and config.json
files for each API.&lt;/p&gt;

&lt;h1 id=&#34;code-generation&#34;&gt;Code generation&lt;/h1&gt;

&lt;p&gt;We are going to generate the code into light-java-example repo, so let&amp;rsquo;s
clone this repo into our working directory.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd ~/networknt
git clone git@github.com:networknt/light-java-example.git
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the above repo, there is a folder discovery contains all the projects
for this tutorial. In order to start from scratch, let&amp;rsquo;s change the existing
folder to discovery.bak as a backup so that you can compare if your code is
not working in each step.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd ~/networknt/light-java-example
mv discovery discovery.bak
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now let&amp;rsquo;s generate the four APIs.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd ~/networknt/swagger
./generate.sh ~/networknt/swagger/api_a ~/networknt/light-java-example/discovery/api_a
./generate.sh ~/networknt/swagger/api_b ~/networknt/light-java-example/discovery/api_b
./generate.sh ~/networknt/swagger/api_c ~/networknt/light-java-example/discovery/api_c
./generate.sh ~/networknt/swagger/api_d ~/networknt/light-java-example/discovery/api_d

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We have four projects generated and compiled under generated folder under each
project folder.&lt;/p&gt;

&lt;h1 id=&#34;test-generated-code&#34;&gt;Test generated code&lt;/h1&gt;

&lt;p&gt;Now you can test the generated projects to make sure they are working with mock
data. We will pick up one project to test it but you can test them all.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd ~/networknt/light-java-example/discovery/api_a/generated
mvn exec:exec
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;From another terminal, access the server with curl command and check the result.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;curl http://localhost:8080/v1/data
[ &amp;quot;aeiou&amp;quot; ]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;At this time, all projects are listening the same port 8080, so you have to shutdown
one server in order to start another one to test them all. The return result should
be the same as they are generated from the similar specifications.&lt;/p&gt;

&lt;h1 id=&#34;static&#34;&gt;Static&lt;/h1&gt;

&lt;p&gt;Now we have four standalone services and the next step is to connect them together.&lt;/p&gt;

&lt;p&gt;Here is the call tree for these services.&lt;/p&gt;

&lt;p&gt;API A will call API B and API C to fulfill its request. API B will call API D
to fulfill its request.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;API A -&amp;gt; API B -&amp;gt; API D
      -&amp;gt; API C
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Before we change the code, let&amp;rsquo;s copy the generated projects to new folders so
that we can compare the changes later on.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd ~/networknt/light-java-example/discovery/api_a
cp -r generated static
cd ~/networknt/light-java-example/discovery/api_b
cp -r generated static
cd ~/networknt/light-java-example/discovery/api_c
cp -r generated static
cd ~/networknt/light-java-example/discovery/api_d
cp -r generated static
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;rsquo;s start update the code in static folders for each project. If you are
using Intellij IDEA Community Edition, you need to open light-java-example
repo and then import each project by right click pom.xml in each static folder.&lt;/p&gt;

&lt;p&gt;As indicated from the title, here we are going to hard code urls in API to API
calls in configuration files. That means these services will be deployed on the
known hosts with known ports. And we will have a config file for each project to
define the calling service urls.&lt;/p&gt;

&lt;h3 id=&#34;api-a&#34;&gt;API A&lt;/h3&gt;

&lt;p&gt;For API A, as it is calling API B and API C, its handler needs to be changed to
calling two other APIs and needs to load a configuration file that define the
urls for API B and API C.&lt;/p&gt;

&lt;p&gt;DataGetHandler.java&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package com.networknt.apia.handler;

import com.fasterxml.jackson.core.type.TypeReference;
import com.networknt.client.Client;
import com.networknt.config.Config;
import com.networknt.exception.ClientException;
import io.undertow.server.HttpHandler;
import io.undertow.server.HttpServerExchange;
import io.undertow.util.HttpString;

import java.io.IOException;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Vector;
import java.util.concurrent.CountDownLatch;

import org.apache.commons.lang3.StringEscapeUtils;
import org.apache.http.HttpResponse;
import org.apache.http.client.methods.HttpGet;
import org.apache.http.concurrent.FutureCallback;
import org.apache.http.impl.nio.client.CloseableHttpAsyncClient;

public class DataGetHandler implements HttpHandler {
    static String CONFIG_NAME = &amp;quot;api_a&amp;quot;;
    static String apibUrl = (String)Config.getInstance().getJsonMapConfig(CONFIG_NAME).get(&amp;quot;api_b_endpoint&amp;quot;);
    static String apicUrl = (String) Config.getInstance().getJsonMapConfig(CONFIG_NAME).get(&amp;quot;api_c_endpoint&amp;quot;);

    @Override
    public void handleRequest(HttpServerExchange exchange) throws Exception {
        List&amp;lt;String&amp;gt; list = new Vector&amp;lt;String&amp;gt;();
        final HttpGet[] requests = new HttpGet[] {
                new HttpGet(apibUrl),
                new HttpGet(apicUrl),
        };
        try {
            CloseableHttpAsyncClient client = Client.getInstance().getAsyncClient();
            final CountDownLatch latch = new CountDownLatch(requests.length);
            for (final HttpGet request: requests) {
                //Client.getInstance().propagateHeaders(request, exchange);
                client.execute(request, new FutureCallback&amp;lt;HttpResponse&amp;gt;() {
                    @Override
                    public void completed(final HttpResponse response) {
                        try {
                            List&amp;lt;String&amp;gt; apiList = (List&amp;lt;String&amp;gt;) Config.getInstance().getMapper().readValue(response.getEntity().getContent(),
                                    new TypeReference&amp;lt;List&amp;lt;String&amp;gt;&amp;gt;(){});
                            list.addAll(apiList);
                        } catch (IOException e) {
                            e.printStackTrace();
                        }
                        latch.countDown();
                    }

                    @Override
                    public void failed(final Exception ex) {
                        ex.printStackTrace();
                        latch.countDown();
                    }

                    @Override
                    public void cancelled() {
                        System.out.println(&amp;quot;cancelled&amp;quot;);
                        latch.countDown();
                    }
                });
            }
            latch.await();
        } catch (ClientException e) {
            e.printStackTrace();
            throw new Exception(&amp;quot;ClientException:&amp;quot;, e);
        }
        // now add API A specific messages
        list.add(&amp;quot;API A: Message 1&amp;quot;);
        list.add(&amp;quot;API A: Message 2&amp;quot;);
        exchange.getResponseSender().send(Config.getInstance().getMapper().writeValueAsString(list));
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The following is the config file that define the url for API B and API C. This is hard
coded and can only be changed in this config file and restart the server. For now, I
am just changing the file in src/main/resources/config folder, but it should be externalized
on official environment.&lt;/p&gt;

&lt;p&gt;api_a.json&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
  &amp;quot;description&amp;quot;: &amp;quot;api_a config&amp;quot;,
  &amp;quot;api_b_endpoint&amp;quot;: &amp;quot;http://localhost:7002/v1/data&amp;quot;,
  &amp;quot;api_c_endpoint&amp;quot;: &amp;quot;http://localhost:7003/v1/data&amp;quot;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As default port for generated server is 8080, we need to change API A to 7001 so that
we can start all servers on the same host.&lt;/p&gt;

&lt;p&gt;server.json&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
  &amp;quot;description&amp;quot;: &amp;quot;server config&amp;quot;,
  &amp;quot;ip&amp;quot;: &amp;quot;0.0.0.0&amp;quot;,
  &amp;quot;port&amp;quot;: 7001,
  &amp;quot;serviceId&amp;quot;: &amp;quot;com.networknt.apia-1.0.0&amp;quot;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;api-b&#34;&gt;API B&lt;/h3&gt;

&lt;p&gt;Change the handler to call API D and load configuration for API D url.&lt;/p&gt;

&lt;p&gt;DataGetHandler.java&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package com.networknt.apib.handler;

import com.fasterxml.jackson.core.type.TypeReference;
import com.networknt.client.Client;
import com.networknt.config.Config;
import com.networknt.exception.ClientException;
import io.undertow.server.HttpHandler;
import io.undertow.server.HttpServerExchange;
import io.undertow.util.HttpString;

import java.io.IOException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import org.apache.commons.lang3.StringEscapeUtils;
import org.apache.http.client.methods.CloseableHttpResponse;
import org.apache.http.client.methods.HttpGet;
import org.apache.http.impl.client.CloseableHttpClient;

public class DataGetHandler implements HttpHandler {
    static String CONFIG_NAME = &amp;quot;api_b&amp;quot;;
    static String apidUrl = (String) Config.getInstance().getJsonMapConfig(CONFIG_NAME).get(&amp;quot;api_d_endpoint&amp;quot;);


    @Override
    public void handleRequest(HttpServerExchange exchange) throws Exception {
        List&amp;lt;String&amp;gt; list = new ArrayList&amp;lt;String&amp;gt;();
        try {
            CloseableHttpClient client = Client.getInstance().getSyncClient();
            HttpGet httpGet = new HttpGet(apidUrl);
            //Client.getInstance().propagateHeaders(httpGet, exchange);
            CloseableHttpResponse response = client.execute(httpGet);
            int responseCode = response.getStatusLine().getStatusCode();
            if(responseCode != 200){
                throw new Exception(&amp;quot;Failed to call API D: &amp;quot; + responseCode);
            }
            List&amp;lt;String&amp;gt; apidList = (List&amp;lt;String&amp;gt;) Config.getInstance().getMapper().readValue(response.getEntity().getContent(),
                    new TypeReference&amp;lt;List&amp;lt;String&amp;gt;&amp;gt;(){});
            list.addAll(apidList);
        } catch (ClientException e) {
            throw new Exception(&amp;quot;Client Exception: &amp;quot;, e);
        } catch (IOException e) {
            throw new Exception(&amp;quot;IOException:&amp;quot;, e);
        }
        // now add API B specific messages
        list.add(&amp;quot;API B: Message 1&amp;quot;);
        list.add(&amp;quot;API B: Message 2&amp;quot;);
        exchange.getResponseSender().send(Config.getInstance().getMapper().writeValueAsString(list));
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Configuration file for API D url.&lt;/p&gt;

&lt;p&gt;api_b.json&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
  &amp;quot;description&amp;quot;: &amp;quot;api_b config&amp;quot;,
  &amp;quot;api_d_endpoint&amp;quot;: &amp;quot;http://localhost:7004/v1/data&amp;quot;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Change port number for API B to 7002 from 8080.
server.json&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
  &amp;quot;description&amp;quot;: &amp;quot;server config&amp;quot;,
  &amp;quot;ip&amp;quot;: &amp;quot;0.0.0.0&amp;quot;,
  &amp;quot;port&amp;quot;: 7002,
  &amp;quot;serviceId&amp;quot;: &amp;quot;com.networknt.apib-1.0.0&amp;quot;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;api-c&#34;&gt;API C&lt;/h3&gt;

&lt;p&gt;Update API C handler to return information that associates with API C.&lt;/p&gt;

&lt;p&gt;DataGetHandler.java&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package com.networknt.apic.handler;

import com.networknt.config.Config;
import io.undertow.server.HttpHandler;
import io.undertow.server.HttpServerExchange;
import io.undertow.util.HttpString;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import org.apache.commons.lang3.StringEscapeUtils;

public class DataGetHandler implements HttpHandler {
    @Override
    public void handleRequest(HttpServerExchange exchange) throws Exception {
        List&amp;lt;String&amp;gt; messages = new ArrayList&amp;lt;String&amp;gt;();
        messages.add(&amp;quot;API C: Message 1&amp;quot;);
        messages.add(&amp;quot;API C: Message 2&amp;quot;);
        exchange.getResponseSender().send(Config.getInstance().getMapper().writeValueAsString(messages));
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Update port number for API C to 7003 from 8080.&lt;/p&gt;

&lt;p&gt;server.json&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
  &amp;quot;description&amp;quot;: &amp;quot;server config&amp;quot;,
  &amp;quot;ip&amp;quot;: &amp;quot;0.0.0.0&amp;quot;,
  &amp;quot;port&amp;quot;: 7003,
  &amp;quot;serviceId&amp;quot;: &amp;quot;com.networknt.apic-1.0.0&amp;quot;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;api-d&#34;&gt;API D&lt;/h3&gt;

&lt;p&gt;Update Handler for API D to return messages related to API D.&lt;/p&gt;

&lt;p&gt;DataGetHandler.java&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package com.networknt.apid.handler;

import com.networknt.config.Config;
import io.undertow.server.HttpHandler;
import io.undertow.server.HttpServerExchange;
import io.undertow.util.HttpString;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import org.apache.commons.lang3.StringEscapeUtils;

public class DataGetHandler implements HttpHandler {
    @Override
    public void handleRequest(HttpServerExchange exchange) throws Exception {
        List&amp;lt;String&amp;gt; messages = new ArrayList&amp;lt;String&amp;gt;();
        messages.add(&amp;quot;API D: Message 1&amp;quot;);
        messages.add(&amp;quot;API D: Message 2&amp;quot;);
        exchange.getResponseSender().send(Config.getInstance().getMapper().writeValueAsString(messages));
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Update port to 7004 from 8080&lt;/p&gt;

&lt;p&gt;server.json&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
  &amp;quot;description&amp;quot;: &amp;quot;server config&amp;quot;,
  &amp;quot;ip&amp;quot;: &amp;quot;0.0.0.0&amp;quot;,
  &amp;quot;port&amp;quot;: 7004,
  &amp;quot;serviceId&amp;quot;: &amp;quot;com.networknt.apid-1.0.0&amp;quot;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;start-servers&#34;&gt;Start Servers&lt;/h3&gt;

&lt;p&gt;Now let&amp;rsquo;s start all four servers from four terminals.&lt;/p&gt;

&lt;p&gt;API A&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd ~/networknt/light-java-example/discovery/api_a/static
mvn clean install exec:exec
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;API B&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd ~/networknt/light-java-example/discovery/api_b/static
mvn clean install exec:exec

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;API C&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd ~/networknt/light-java-example/discovery/api_c/static
mvn clean install exec:exec

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;API D&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd ~/networknt/light-java-example/discovery/api_d/static
mvn clean install exec:exec

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;test-servers&#34;&gt;Test Servers&lt;/h3&gt;

&lt;p&gt;Let&amp;rsquo;s access API A and see if we can get messages from all four servers.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;curl http://localhost:7001/v1/data

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The result is&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[&amp;quot;API C: Message 1&amp;quot;,&amp;quot;API C: Message 2&amp;quot;,&amp;quot;API D: Message 1&amp;quot;,&amp;quot;API D: Message 2&amp;quot;,&amp;quot;API B: Message 1&amp;quot;,&amp;quot;API B: Message 2&amp;quot;,&amp;quot;API A: Message 1&amp;quot;,&amp;quot;API A: Message 2&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;dynamic&#34;&gt;Dynamic&lt;/h1&gt;

&lt;p&gt;The above step uses static urls defined in configuration files. It won&amp;rsquo;t work in a
dynamic clustered environment as there are more instances of each service. In this
step, we are going to use cluster component with direct registry so that we don&amp;rsquo;t
need to start external consul or zookeeper instances. We still go through registry
for service discovery but the registry is defined in service.json. Next step we
will use consul server for the discovery to mimic real production environment.&lt;/p&gt;

&lt;p&gt;First let&amp;rsquo;s create a folder from static to dynamic.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd ~/networknt/light-java-example/discovery/api_a
cp -r static dynamic
cd ~/networknt/light-java-example/discovery/api_b
cp -r static dynamic
cd ~/networknt/light-java-example/discovery/api_c
cp -r static dynamic
cd ~/networknt/light-java-example/discovery/api_d
cp -r static dynamic
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;api-a-1&#34;&gt;API A&lt;/h3&gt;

&lt;p&gt;Let&amp;rsquo;s update API A Handler to use Cluster instance instead of using static config
files.&lt;/p&gt;

&lt;p&gt;DataGetHandler.java&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package com.networknt.apia.handler;

import com.fasterxml.jackson.core.type.TypeReference;
import com.networknt.client.Client;
import com.networknt.cluster.Cluster;
import com.networknt.config.Config;
import com.networknt.exception.ClientException;
import com.networknt.service.SingletonServiceFactory;
import io.undertow.server.HttpHandler;
import io.undertow.server.HttpServerExchange;

import java.io.IOException;
import java.util.List;
import java.util.Vector;
import java.util.concurrent.CountDownLatch;

import org.apache.http.HttpResponse;
import org.apache.http.client.methods.HttpGet;
import org.apache.http.concurrent.FutureCallback;
import org.apache.http.impl.nio.client.CloseableHttpAsyncClient;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class DataGetHandler implements HttpHandler {
    private static Logger logger = LoggerFactory.getLogger(DataGetHandler.class);
    private static Cluster cluster = (Cluster) SingletonServiceFactory.getBean(Cluster.class);

    @Override
    public void handleRequest(HttpServerExchange exchange) throws Exception {
        List&amp;lt;String&amp;gt; list = new Vector&amp;lt;&amp;gt;();

        String apibUrl = cluster.serviceToUrl(&amp;quot;http&amp;quot;, &amp;quot;com.networknt.apib-1.0.0&amp;quot;) + &amp;quot;/v1/data&amp;quot;;
        if(logger.isDebugEnabled()) logger.debug(&amp;quot;apibUrl = &amp;quot; + apibUrl);
        String apicUrl = cluster.serviceToUrl(&amp;quot;http&amp;quot;, &amp;quot;com.networknt.apic-1.0.0&amp;quot;) + &amp;quot;/v1/data&amp;quot;;
        if(logger.isDebugEnabled()) logger.debug(&amp;quot;apicUrl = &amp;quot; + apicUrl);
        final HttpGet[] requests = new HttpGet[] {
                new HttpGet(apibUrl),
                new HttpGet(apicUrl),
        };
        try {
            CloseableHttpAsyncClient client = Client.getInstance().getAsyncClient();
            final CountDownLatch latch = new CountDownLatch(requests.length);
            for (final HttpGet request: requests) {
                //Client.getInstance().propagateHeaders(request, exchange);
                client.execute(request, new FutureCallback&amp;lt;HttpResponse&amp;gt;() {
                    @Override
                    public void completed(final HttpResponse response) {
                        try {
                            List&amp;lt;String&amp;gt; apiList = Config.getInstance().getMapper().readValue(response.getEntity().getContent(),
                                    new TypeReference&amp;lt;List&amp;lt;String&amp;gt;&amp;gt;(){});
                            list.addAll(apiList);
                        } catch (IOException e) {
                            e.printStackTrace();
                        }
                        latch.countDown();
                    }

                    @Override
                    public void failed(final Exception ex) {
                        ex.printStackTrace();
                        latch.countDown();
                    }

                    @Override
                    public void cancelled() {
                        System.out.println(&amp;quot;cancelled&amp;quot;);
                        latch.countDown();
                    }
                });
            }
            latch.await();
        } catch (ClientException e) {
            e.printStackTrace();
            throw new Exception(&amp;quot;ClientException:&amp;quot;, e);
        }
        // now add API A specific messages
        list.add(&amp;quot;API A: Message 1&amp;quot;);
        list.add(&amp;quot;API A: Message 2&amp;quot;);
        exchange.getResponseSender().send(Config.getInstance().getMapper().writeValueAsString(list));
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For discovery, some new modules should be included into the pom.xml.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;com.networknt&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;service&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;${version.light-java}&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;com.networknt&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;registry&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;${version.light-java}&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;com.networknt&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;balance&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;${version.light-java}&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;com.networknt&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;cluster&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;${version.light-java}&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;com.networknt&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;consul&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;${version.light-java}&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Also, we need service.json to inject several singleton implementations of
Cluster, LoadBanlance, URL and Registry. Please note that the key in parameters
is serviceId of your calling APIs&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
  &amp;quot;description&amp;quot;: &amp;quot;singleton service factory configuration&amp;quot;,
  &amp;quot;singletons&amp;quot;: [
    {
      &amp;quot;com.networknt.registry.URL&amp;quot;: [
        {
          &amp;quot;com.networknt.registry.URLImpl&amp;quot;: {
            &amp;quot;protocol&amp;quot;: &amp;quot;https&amp;quot;,
            &amp;quot;host&amp;quot;: &amp;quot;localhost&amp;quot;,
            &amp;quot;port&amp;quot;: 8080,
            &amp;quot;path&amp;quot;: &amp;quot;direct&amp;quot;,
            &amp;quot;parameters&amp;quot;: {
              &amp;quot;com.networknt.apib-1.0.0&amp;quot;: &amp;quot;http://localhost:7002&amp;quot;,
              &amp;quot;com.networknt.apic-1.0.0&amp;quot;: &amp;quot;http://localhost:7003&amp;quot;
            }
          }
        }
      ]
    },
    {
      &amp;quot;com.networknt.registry.Registry&amp;quot; : [
        &amp;quot;com.networknt.registry.support.DirectRegistry&amp;quot;
      ]
    },
    {
      &amp;quot;com.networknt.balance.LoadBalance&amp;quot; : [
        &amp;quot;com.networknt.balance.RoundRobinLoadBalance&amp;quot;
      ]
    },
    {
      &amp;quot;com.networknt.cluster.Cluster&amp;quot; : [
        &amp;quot;com.networknt.cluster.LightCluster&amp;quot;
      ]
    }
  ]
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;api-b-1&#34;&gt;API B&lt;/h3&gt;

&lt;p&gt;DataGetHandler.java&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package com.networknt.apib.handler;

import com.fasterxml.jackson.core.type.TypeReference;
import com.networknt.client.Client;
import com.networknt.cluster.Cluster;
import com.networknt.config.Config;
import com.networknt.exception.ClientException;
import com.networknt.service.SingletonServiceFactory;
import io.undertow.server.HttpHandler;
import io.undertow.server.HttpServerExchange;
import io.undertow.util.HttpString;

import java.io.IOException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import org.apache.commons.lang3.StringEscapeUtils;
import org.apache.http.client.methods.CloseableHttpResponse;
import org.apache.http.client.methods.HttpGet;
import org.apache.http.impl.client.CloseableHttpClient;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class DataGetHandler implements HttpHandler {
    private static Logger logger = LoggerFactory.getLogger(DataGetHandler.class);
    private static Cluster cluster = (Cluster) SingletonServiceFactory.getBean(Cluster.class);

    @Override
    public void handleRequest(HttpServerExchange exchange) throws Exception {
        List&amp;lt;String&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();
        String apidUrl = cluster.serviceToUrl(&amp;quot;http&amp;quot;, &amp;quot;com.networknt.apid-1.0.0&amp;quot;) + &amp;quot;/v1/data&amp;quot;;
        if(logger.isDebugEnabled()) logger.debug(&amp;quot;apidUrl = &amp;quot; + apidUrl);

        try {
            CloseableHttpClient client = Client.getInstance().getSyncClient();
            HttpGet httpGet = new HttpGet(apidUrl);
            //Client.getInstance().propagateHeaders(httpGet, exchange);
            CloseableHttpResponse response = client.execute(httpGet);
            int responseCode = response.getStatusLine().getStatusCode();
            if(responseCode != 200){
                throw new Exception(&amp;quot;Failed to call API D: &amp;quot; + responseCode);
            }
            List&amp;lt;String&amp;gt; apidList = Config.getInstance().getMapper().readValue(response.getEntity().getContent(),
                    new TypeReference&amp;lt;List&amp;lt;String&amp;gt;&amp;gt;(){});
            list.addAll(apidList);
        } catch (ClientException e) {
            throw new Exception(&amp;quot;Client Exception: &amp;quot;, e);
        } catch (IOException e) {
            throw new Exception(&amp;quot;IOException:&amp;quot;, e);
        }
        // now add API B specific messages
        list.add(&amp;quot;API B: Message 1&amp;quot;);
        list.add(&amp;quot;API B: Message 2&amp;quot;);
        exchange.getResponseSender().send(Config.getInstance().getMapper().writeValueAsString(list));
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As API B is calling API D, it needs discovery as well and the following dependencies
should be added to pom.xml&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;com.networknt&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;service&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;${version.light-java}&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;com.networknt&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;registry&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;${version.light-java}&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;com.networknt&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;balance&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;${version.light-java}&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;com.networknt&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;cluster&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;${version.light-java}&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;com.networknt&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;consul&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;${version.light-java}&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Inject interface implementations and define the API D url.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
  &amp;quot;description&amp;quot;: &amp;quot;singleton service factory configuration&amp;quot;,
  &amp;quot;singletons&amp;quot;: [
    {
      &amp;quot;com.networknt.registry.URL&amp;quot;: [
        {
          &amp;quot;com.networknt.registry.URLImpl&amp;quot;: {
            &amp;quot;protocol&amp;quot;: &amp;quot;https&amp;quot;,
            &amp;quot;host&amp;quot;: &amp;quot;localhost&amp;quot;,
            &amp;quot;port&amp;quot;: 8080,
            &amp;quot;path&amp;quot;: &amp;quot;direct&amp;quot;,
            &amp;quot;parameters&amp;quot;: {
              &amp;quot;com.networknt.apid-1.0.0&amp;quot;: &amp;quot;http://localhost:7004&amp;quot;
            }
          }
        }
      ]
    },
    {
      &amp;quot;com.networknt.registry.Registry&amp;quot; : [
        &amp;quot;com.networknt.registry.support.DirectRegistry&amp;quot;
      ]
    },
    {
      &amp;quot;com.networknt.balance.LoadBalance&amp;quot; : [
        &amp;quot;com.networknt.balance.RoundRobinLoadBalance&amp;quot;
      ]
    },
    {
      &amp;quot;com.networknt.cluster.Cluster&amp;quot; : [
        &amp;quot;com.networknt.cluster.LightCluster&amp;quot;
      ]
    }
  ]
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;api-c-1&#34;&gt;API C&lt;/h3&gt;

&lt;p&gt;API C is not calling any other APIs, so there is no change to its handler.&lt;/p&gt;

&lt;h3 id=&#34;api-d-1&#34;&gt;API D&lt;/h3&gt;

&lt;p&gt;API D is not calling any other APIs, so there is no change to its handler.&lt;/p&gt;

&lt;h3 id=&#34;start-servers-1&#34;&gt;Start Servers&lt;/h3&gt;

&lt;p&gt;Now let&amp;rsquo;s start all four servers from four terminals.&lt;/p&gt;

&lt;p&gt;API A&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd ~/networknt/light-java-example/discovery/api_a/dynamic
mvn clean install exec:exec
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;API B&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd ~/networknt/light-java-example/discovery/api_b/dynamic
mvn clean install exec:exec

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;API C&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd ~/networknt/light-java-example/discovery/api_c/dynamic
mvn clean install exec:exec

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;API D&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd ~/networknt/light-java-example/discovery/api_d/dynamic
mvn clean install exec:exec

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;test-servers-1&#34;&gt;Test Servers&lt;/h3&gt;

&lt;p&gt;Let&amp;rsquo;s access API A and see if we can get messages from all four servers.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;curl http://localhost:7001/v1/data

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The result is&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[&amp;quot;API C: Message 1&amp;quot;,&amp;quot;API C: Message 2&amp;quot;,&amp;quot;API D: Message 1&amp;quot;,&amp;quot;API D: Message 2&amp;quot;,&amp;quot;API B: Message 1&amp;quot;,&amp;quot;API B: Message 2&amp;quot;,&amp;quot;API A: Message 1&amp;quot;,&amp;quot;API A: Message 2&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;multiple-api-d-instances&#34;&gt;Multiple API D Instances&lt;/h1&gt;

&lt;p&gt;In this step, we are going to start two API D instances that listening to 70041 and 70042.&lt;/p&gt;

&lt;p&gt;Now let&amp;rsquo;s copy from dynamic to multiple for each API.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd ~/networknt/light-java-example/discovery/api_a
cp -r dynamic multiple
cd ~/networknt/light-java-example/discovery/api_b
cp -r dynamic multiple
cd ~/networknt/light-java-example/discovery/api_c
cp -r dynamic multiple
cd ~/networknt/light-java-example/discovery/api_d
cp -r dynamic multiple
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;api-b-2&#34;&gt;API B&lt;/h3&gt;

&lt;p&gt;Let&amp;rsquo;s modify API B service.json to have two API D instances that listen to 70041
and 70042.&lt;/p&gt;

&lt;p&gt;service.json&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
  &amp;quot;description&amp;quot;: &amp;quot;singleton service factory configuration&amp;quot;,
  &amp;quot;singletons&amp;quot;: [
    {
      &amp;quot;com.networknt.registry.URL&amp;quot;: [
        {
          &amp;quot;com.networknt.registry.URLImpl&amp;quot;: {
            &amp;quot;protocol&amp;quot;: &amp;quot;https&amp;quot;,
            &amp;quot;host&amp;quot;: &amp;quot;localhost&amp;quot;,
            &amp;quot;port&amp;quot;: 8080,
            &amp;quot;path&amp;quot;: &amp;quot;direct&amp;quot;,
            &amp;quot;parameters&amp;quot;: {
              &amp;quot;com.networknt.apid-1.0.0&amp;quot;: &amp;quot;http://localhost:7004,http://localhost:7005&amp;quot;
            }
          }
        }
      ]
    },
    {
      &amp;quot;com.networknt.registry.Registry&amp;quot; : [
        &amp;quot;com.networknt.registry.support.DirectRegistry&amp;quot;
      ]
    },
    {
      &amp;quot;com.networknt.balance.LoadBalance&amp;quot; : [
        &amp;quot;com.networknt.balance.RoundRobinLoadBalance&amp;quot;
      ]
    },
    {
      &amp;quot;com.networknt.cluster.Cluster&amp;quot; : [
        &amp;quot;com.networknt.cluster.LightCluster&amp;quot;
      ]
    }
  ]
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;api-d-2&#34;&gt;API D&lt;/h3&gt;

&lt;p&gt;In order to start two instances with the same code base, we need to modify the
server.json before starting the server.&lt;/p&gt;

&lt;p&gt;Also, let&amp;rsquo;s update the handler so that we know which port serves the request.&lt;/p&gt;

&lt;p&gt;DataGetHandler.java&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package com.networknt.apid.handler;

import com.networknt.config.Config;
import com.networknt.server.Server;
import io.undertow.server.HttpHandler;
import io.undertow.server.HttpServerExchange;
import io.undertow.util.HttpString;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import org.apache.commons.lang3.StringEscapeUtils;

public class DataGetHandler implements HttpHandler {
    @Override
    public void handleRequest(HttpServerExchange exchange) throws Exception {
        int port = Server.config.getPort();
        List&amp;lt;String&amp;gt; messages = new ArrayList&amp;lt;String&amp;gt;();
        messages.add(&amp;quot;API D: Message 1 from port &amp;quot; + port);
        messages.add(&amp;quot;API D: Message 2 from port &amp;quot; + port);
        exchange.getResponseSender().send(Config.getInstance().getMapper().writeValueAsString(messages));
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;start-servers-2&#34;&gt;Start Servers&lt;/h3&gt;

&lt;p&gt;Now let&amp;rsquo;s start all five servers from five terminals. API D has two instances.&lt;/p&gt;

&lt;p&gt;API A&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd ~/networknt/light-java-example/discovery/api_a/multiple
mvn clean install exec:exec
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;API B&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd ~/networknt/light-java-example/discovery/api_b/multiple
mvn clean install exec:exec

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;API C&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd ~/networknt/light-java-example/discovery/api_c/multiple
mvn clean install exec:exec

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;API D&lt;/p&gt;

&lt;p&gt;And start the first instance that listen to 7004.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd ~/networknt/light-java-example/discovery/api_d/multiple
mvn clean install exec:exec

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now let&amp;rsquo;s start the second instance. Before starting the serer, let&amp;rsquo;s update
server.json with port 7005.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
  &amp;quot;description&amp;quot;: &amp;quot;server config&amp;quot;,
  &amp;quot;ip&amp;quot;: &amp;quot;0.0.0.0&amp;quot;,
  &amp;quot;port&amp;quot;: 7005,
  &amp;quot;serviceId&amp;quot;: &amp;quot;com.networknt.apid-1.0.0&amp;quot;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And start the second instance&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd ~/networknt/light-java-example/discovery/api_d/multiple
mvn clean install exec:exec

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;test-servers-2&#34;&gt;Test Servers&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;curl http://localhost:7001/v1/data
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And the result can be the following alternatively.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[&amp;quot;API C: Message 1&amp;quot;,&amp;quot;API C: Message 2&amp;quot;,&amp;quot;API D: Message 1 from port 7004&amp;quot;,&amp;quot;API D: Message 2 from port 7004&amp;quot;,&amp;quot;API B: Message 1&amp;quot;,&amp;quot;API B: Message 2&amp;quot;,&amp;quot;API A: Message 1&amp;quot;,&amp;quot;API A: Message 2&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;or&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[&amp;quot;API C: Message 1&amp;quot;,&amp;quot;API C: Message 2&amp;quot;,&amp;quot;API D: Message 1 from port 7005&amp;quot;,&amp;quot;API D: Message 2 from port 7005&amp;quot;,&amp;quot;API B: Message 1&amp;quot;,&amp;quot;API B: Message 2&amp;quot;,&amp;quot;API A: Message 1&amp;quot;,&amp;quot;API A: Message 2&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;consul&#34;&gt;Consul&lt;/h1&gt;

&lt;p&gt;Above step multiple demonstrates how to use direct registry to enable load balance and
it works the same way as Consul and Zookeeper registry. In this step, we are going to
use Consul for registry to enable cluster.&lt;/p&gt;

&lt;p&gt;Now let&amp;rsquo;s copy from multiple to consul for each API.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd ~/networknt/light-java-example/discovery/api_a
cp -r multiple consul
cd ~/networknt/light-java-example/discovery/api_b
cp -r multiple consul
cd ~/networknt/light-java-example/discovery/api_c
cp -r multiple consul
cd ~/networknt/light-java-example/discovery/api_d
cp -r multiple consul
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;api-a-2&#34;&gt;API A&lt;/h3&gt;

&lt;p&gt;In order to switch from direct registry to consul registry, we just need to update
service.json configuration to inject the consul implementation to the registry interface.&lt;/p&gt;

&lt;p&gt;service.json&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
  &amp;quot;description&amp;quot;: &amp;quot;singleton service factory configuration&amp;quot;,
  &amp;quot;singletons&amp;quot;: [
    {
      &amp;quot;com.networknt.registry.URL&amp;quot;: [
        {
          &amp;quot;com.networknt.registry.URLImpl&amp;quot;: {
            &amp;quot;protocol&amp;quot;: &amp;quot;light&amp;quot;,
            &amp;quot;host&amp;quot;: &amp;quot;localhost&amp;quot;,
            &amp;quot;port&amp;quot;: 8080,
            &amp;quot;path&amp;quot;: &amp;quot;consul&amp;quot;,
            &amp;quot;parameters&amp;quot;: {
              &amp;quot;registryRetryPeriod&amp;quot;: &amp;quot;30000&amp;quot;
            }
          }
        }
      ]
    },
    {
      &amp;quot;com.networknt.consul.client.ConsulClient&amp;quot;: [
        {
          &amp;quot;com.networknt.consul.client.ConsulEcwidClient&amp;quot;: [
            {&amp;quot;java.lang.String&amp;quot;: &amp;quot;localhost&amp;quot;},
            {&amp;quot;int&amp;quot;: 8500}
          ]
        }
      ]
    },
    {
      &amp;quot;com.networknt.registry.Registry&amp;quot; : [
        &amp;quot;com.networknt.consul.ConsulRegistry&amp;quot;
      ]
    },
    {
      &amp;quot;com.networknt.balance.LoadBalance&amp;quot; : [
        &amp;quot;com.networknt.balance.RoundRobinLoadBalance&amp;quot;
      ]
    },
    {
      &amp;quot;com.networknt.cluster.Cluster&amp;quot; : [
        &amp;quot;com.networknt.cluster.LightCluster&amp;quot;
      ]
    }
  ]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Although in our case, there is no caller service for API A, we still need to register
it to consul by enable it in server.json&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
  &amp;quot;description&amp;quot;: &amp;quot;server config&amp;quot;,
  &amp;quot;ip&amp;quot;: &amp;quot;0.0.0.0&amp;quot;,
  &amp;quot;port&amp;quot;: 7001,
  &amp;quot;serviceId&amp;quot;: &amp;quot;com.networknt.apia-1.0.0&amp;quot;,
  &amp;quot;enableRegistry&amp;quot;: true
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;api-b-3&#34;&gt;API B&lt;/h3&gt;

&lt;p&gt;Let&amp;rsquo;s update service.json to inject consul registry instead of direct registry used in
the previous step.&lt;/p&gt;

&lt;p&gt;service.json&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
  &amp;quot;description&amp;quot;: &amp;quot;singleton service factory configuration&amp;quot;,
  &amp;quot;singletons&amp;quot;: [
    {
      &amp;quot;com.networknt.registry.URL&amp;quot;: [
        {
          &amp;quot;com.networknt.registry.URLImpl&amp;quot;: {
            &amp;quot;protocol&amp;quot;: &amp;quot;light&amp;quot;,
            &amp;quot;host&amp;quot;: &amp;quot;localhost&amp;quot;,
            &amp;quot;port&amp;quot;: 8080,
            &amp;quot;path&amp;quot;: &amp;quot;consul&amp;quot;,
            &amp;quot;parameters&amp;quot;: {
              &amp;quot;registryRetryPeriod&amp;quot;: &amp;quot;30000&amp;quot;
            }
          }
        }
      ]
    },
    {
      &amp;quot;com.networknt.consul.client.ConsulClient&amp;quot;: [
        {
          &amp;quot;com.networknt.consul.client.ConsulEcwidClient&amp;quot;: [
            {&amp;quot;java.lang.String&amp;quot;: &amp;quot;localhost&amp;quot;},
            {&amp;quot;int&amp;quot;: 8500}
          ]
        }
      ]
    },
    {
      &amp;quot;com.networknt.registry.Registry&amp;quot; : [
        &amp;quot;com.networknt.consul.ConsulRegistry&amp;quot;
      ]
    },
    {
      &amp;quot;com.networknt.balance.LoadBalance&amp;quot; : [
        &amp;quot;com.networknt.balance.RoundRobinLoadBalance&amp;quot;
      ]
    },
    {
      &amp;quot;com.networknt.cluster.Cluster&amp;quot; : [
        &amp;quot;com.networknt.cluster.LightCluster&amp;quot;
      ]
    }
  ]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As API B will be called by API A, it needs to register itself to consul registry so
that API A can discover it through the same consul registry. To do that you only need
to enable server registry in config file.&lt;/p&gt;

&lt;p&gt;server.json&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
  &amp;quot;description&amp;quot;: &amp;quot;server config&amp;quot;,
  &amp;quot;ip&amp;quot;: &amp;quot;0.0.0.0&amp;quot;,
  &amp;quot;port&amp;quot;: 7002,
  &amp;quot;serviceId&amp;quot;: &amp;quot;com.networknt.apib-1.0.0&amp;quot;,
  &amp;quot;enableRegistry&amp;quot;: true
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;api-c-2&#34;&gt;API C&lt;/h3&gt;

&lt;p&gt;Although API C is not calling any other APIs, it needs to register itself to consul
so that API A can discovery it from the same consul registry.&lt;/p&gt;

&lt;p&gt;service.json&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
  &amp;quot;description&amp;quot;: &amp;quot;singleton service factory configuration&amp;quot;,
  &amp;quot;singletons&amp;quot;: [
    {
      &amp;quot;com.networknt.registry.URL&amp;quot;: [
        {
          &amp;quot;com.networknt.registry.URLImpl&amp;quot;: {
            &amp;quot;protocol&amp;quot;: &amp;quot;light&amp;quot;,
            &amp;quot;host&amp;quot;: &amp;quot;localhost&amp;quot;,
            &amp;quot;port&amp;quot;: 8080,
            &amp;quot;path&amp;quot;: &amp;quot;consul&amp;quot;,
            &amp;quot;parameters&amp;quot;: {
              &amp;quot;registryRetryPeriod&amp;quot;: &amp;quot;30000&amp;quot;
            }
          }
        }
      ]
    },
    {
      &amp;quot;com.networknt.consul.client.ConsulClient&amp;quot;: [
        {
          &amp;quot;com.networknt.consul.client.ConsulEcwidClient&amp;quot;: [
            {&amp;quot;java.lang.String&amp;quot;: &amp;quot;localhost&amp;quot;},
            {&amp;quot;int&amp;quot;: 8500}
          ]
        }
      ]
    },
    {
      &amp;quot;com.networknt.registry.Registry&amp;quot; : [
        &amp;quot;com.networknt.consul.ConsulRegistry&amp;quot;
      ]
    },
    {
      &amp;quot;com.networknt.balance.LoadBalance&amp;quot; : [
        &amp;quot;com.networknt.balance.RoundRobinLoadBalance&amp;quot;
      ]
    },
    {
      &amp;quot;com.networknt.cluster.Cluster&amp;quot; : [
        &amp;quot;com.networknt.cluster.LightCluster&amp;quot;
      ]
    }
  ]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;server.json&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
  &amp;quot;description&amp;quot;: &amp;quot;server config&amp;quot;,
  &amp;quot;ip&amp;quot;: &amp;quot;0.0.0.0&amp;quot;,
  &amp;quot;port&amp;quot;: 7003,
  &amp;quot;serviceId&amp;quot;: &amp;quot;com.networknt.apic-1.0.0&amp;quot;,
  &amp;quot;enableRegistry&amp;quot;: true
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Also, in previous step, we didn&amp;rsquo;t add extra dependencies for registry, load balance
cluster and consul modules. Let&amp;rsquo;s add them here in pom.xml&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;com.networknt&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;registry&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;${version.light-java}&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;com.networknt&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;balance&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;${version.light-java}&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;com.networknt&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;cluster&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;${version.light-java}&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;com.networknt&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;consul&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;${version.light-java}&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;api-d-3&#34;&gt;API D&lt;/h3&gt;

&lt;p&gt;Although API D is not calling any other APIs, it needs to register itself to consul
so that API B can discovery it from the same consul registry.&lt;/p&gt;

&lt;p&gt;service.json&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
  &amp;quot;description&amp;quot;: &amp;quot;singleton service factory configuration&amp;quot;,
  &amp;quot;singletons&amp;quot;: [
    {
      &amp;quot;com.networknt.registry.URL&amp;quot;: [
        {
          &amp;quot;com.networknt.registry.URLImpl&amp;quot;: {
            &amp;quot;protocol&amp;quot;: &amp;quot;light&amp;quot;,
            &amp;quot;host&amp;quot;: &amp;quot;localhost&amp;quot;,
            &amp;quot;port&amp;quot;: 8080,
            &amp;quot;path&amp;quot;: &amp;quot;consul&amp;quot;,
            &amp;quot;parameters&amp;quot;: {
              &amp;quot;registryRetryPeriod&amp;quot;: &amp;quot;30000&amp;quot;
            }
          }
        }
      ]
    },
    {
      &amp;quot;com.networknt.consul.client.ConsulClient&amp;quot;: [
        {
          &amp;quot;com.networknt.consul.client.ConsulEcwidClient&amp;quot;: [
            {&amp;quot;java.lang.String&amp;quot;: &amp;quot;localhost&amp;quot;},
            {&amp;quot;int&amp;quot;: 8500}
          ]
        }
      ]
    },
    {
      &amp;quot;com.networknt.registry.Registry&amp;quot; : [
        &amp;quot;com.networknt.consul.ConsulRegistry&amp;quot;
      ]
    },
    {
      &amp;quot;com.networknt.balance.LoadBalance&amp;quot; : [
        &amp;quot;com.networknt.balance.RoundRobinLoadBalance&amp;quot;
      ]
    },
    {
      &amp;quot;com.networknt.cluster.Cluster&amp;quot; : [
        &amp;quot;com.networknt.cluster.LightCluster&amp;quot;
      ]
    }
  ]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;server.json&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
  &amp;quot;description&amp;quot;: &amp;quot;server config&amp;quot;,
  &amp;quot;ip&amp;quot;: &amp;quot;0.0.0.0&amp;quot;,
  &amp;quot;port&amp;quot;: 7004,
  &amp;quot;serviceId&amp;quot;: &amp;quot;com.networknt.apid-1.0.0&amp;quot;,
  &amp;quot;enableRegistry&amp;quot;: true
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Also add extra dependencies to pom.xml to enable cluster.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;com.networknt&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;registry&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;${version.light-java}&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;com.networknt&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;balance&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;${version.light-java}&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;com.networknt&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;cluster&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;${version.light-java}&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;com.networknt&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;consul&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;${version.light-java}&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;start-consul&#34;&gt;Start Consul&lt;/h3&gt;

&lt;p&gt;Here we are starting consul server in docker to serve as a centralized registry. To make it
simpler, the ACL in consul is disable by setting acl_default_policy=allow.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker run -d -p 8400:8400 -p 8500:8500/tcp -p 8600:53/udp -e &#39;CONSUL_LOCAL_CONFIG={&amp;quot;acl_datacenter&amp;quot;:&amp;quot;dc1&amp;quot;,&amp;quot;acl_default_policy&amp;quot;:&amp;quot;allow&amp;quot;,&amp;quot;acl_down_policy&amp;quot;:&amp;quot;extend-cache&amp;quot;,&amp;quot;acl_master_token&amp;quot;:&amp;quot;the_one_ring&amp;quot;,&amp;quot;bootstrap_expect&amp;quot;:1,&amp;quot;datacenter&amp;quot;:&amp;quot;dc1&amp;quot;,&amp;quot;data_dir&amp;quot;:&amp;quot;/usr/local/bin/consul.d/data&amp;quot;,&amp;quot;server&amp;quot;:true}&#39; consul agent -server -ui -bind=127.0.0.1 -client=0.0.0.0
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;start-four-servers&#34;&gt;Start four servers&lt;/h3&gt;

&lt;p&gt;Now let&amp;rsquo;s start four terminals to start servers.&lt;/p&gt;

&lt;p&gt;API A&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd ~/networknt/light-java-example/discovery/api_a/consul
mvn clean install exec:exec
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;API B&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd ~/networknt/light-java-example/discovery/api_b/consul
mvn clean install exec:exec

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;API C&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd ~/networknt/light-java-example/discovery/api_c/consul
mvn clean install exec:exec

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;API D&lt;/p&gt;

&lt;p&gt;And start the first instance that listen to 7004 as default&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd ~/networknt/light-java-example/discovery/api_d/consul
mvn clean install exec:exec

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;test-four-servers&#34;&gt;Test four servers&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;curl http://localhost:7001/v1/data
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And the result will be&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[&amp;quot;API C: Message 1&amp;quot;,&amp;quot;API C: Message 2&amp;quot;,&amp;quot;API D: Message 1 from port 7004&amp;quot;,&amp;quot;API D: Message 2 from port 7004&amp;quot;,&amp;quot;API B: Message 1&amp;quot;,&amp;quot;API B: Message 2&amp;quot;,&amp;quot;API A: Message 1&amp;quot;,&amp;quot;API A: Message 2&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;start-another-api-d&#34;&gt;Start another API D&lt;/h3&gt;

&lt;p&gt;Now let&amp;rsquo;s start the second instance of API D. Before starting the serer, let&amp;rsquo;s update
server.json with port 7005.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
  &amp;quot;description&amp;quot;: &amp;quot;server config&amp;quot;,
  &amp;quot;ip&amp;quot;: &amp;quot;0.0.0.0&amp;quot;,
  &amp;quot;port&amp;quot;: 7005,
  &amp;quot;serviceId&amp;quot;: &amp;quot;com.networknt.apid-1.0.0&amp;quot;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And start the second instance&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd ~/networknt/light-java-example/discovery/api_d/consul
mvn clean install exec:exec

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;test-servers-3&#34;&gt;Test Servers&lt;/h3&gt;

&lt;p&gt;Wait 10 seconds, your API B cached API D service urls will be updated automatically
with the new instance. Now you have to instance of API D to serve API B.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;curl http://localhost:7001/v1/data
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And the result can be the following alternatively.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[&amp;quot;API C: Message 1&amp;quot;,&amp;quot;API C: Message 2&amp;quot;,&amp;quot;API D: Message 1 from port 7004&amp;quot;,&amp;quot;API D: Message 2 from port 7004&amp;quot;,&amp;quot;API B: Message 1&amp;quot;,&amp;quot;API B: Message 2&amp;quot;,&amp;quot;API A: Message 1&amp;quot;,&amp;quot;API A: Message 2&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;or&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[&amp;quot;API C: Message 1&amp;quot;,&amp;quot;API C: Message 2&amp;quot;,&amp;quot;API D: Message 1 from port 7005&amp;quot;,&amp;quot;API D: Message 2 from port 7005&amp;quot;,&amp;quot;API B: Message 1&amp;quot;,&amp;quot;API B: Message 2&amp;quot;,&amp;quot;API A: Message 1&amp;quot;,&amp;quot;API A: Message 2&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;shutdown-one-api-d&#34;&gt;Shutdown one API D&lt;/h3&gt;

&lt;p&gt;Let&amp;rsquo;s shutdown one instance of API D and wait for 10 seconds. Now when you call the same
curl command, API D message will be always served by the same port which is the one still
running.&lt;/p&gt;

&lt;h1 id=&#34;docker&#34;&gt;Docker&lt;/h1&gt;

&lt;p&gt;In this step, we are going to dockerize all the APIs and then use registrator for service
registry.&lt;/p&gt;

&lt;p&gt;Now let&amp;rsquo;s copy from consul to docker for each API.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd ~/networknt/light-java-example/discovery/api_a
cp -r consul consuldocker
cd ~/networknt/light-java-example/discovery/api_b
cp -r consul consuldocker
cd ~/networknt/light-java-example/discovery/api_c
cp -r consul consuldocker
cd ~/networknt/light-java-example/discovery/api_d
cp -r consul consulcdocker
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Before starting the services, let&amp;rsquo;s start consul and registrator.&lt;/p&gt;

&lt;p&gt;Consul&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker run -d -p 8400:8400 -p 8500:8500/tcp -p 8600:53/udp -e &#39;CONSUL_LOCAL_CONFIG={&amp;quot;acl_datacenter&amp;quot;:&amp;quot;dc1&amp;quot;,&amp;quot;acl_default_policy&amp;quot;:&amp;quot;allow&amp;quot;,&amp;quot;acl_down_policy&amp;quot;:&amp;quot;extend-cache&amp;quot;,&amp;quot;acl_master_token&amp;quot;:&amp;quot;the_one_ring&amp;quot;,&amp;quot;bootstrap_expect&amp;quot;:1,&amp;quot;datacenter&amp;quot;:&amp;quot;dc1&amp;quot;,&amp;quot;data_dir&amp;quot;:&amp;quot;/usr/local/bin/consul.d/data&amp;quot;,&amp;quot;server&amp;quot;:true}&#39; consul agent -server -ui -bind=127.0.0.1 -client=0.0.0.0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Regsitrator&lt;/p&gt;

&lt;p&gt;We use -ip 127.0.0.1 in the command line to make sure that ServiceAddress in
consul is populated with ip and port. The latest version of regsitrator won&amp;rsquo;t
set default ip anymore.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker run -d --name=registrator --net=host --volume=/var/run/docker.sock:/tmp/docker.sock gliderlabs/registrator:latest -ip 127.0.0.1 consul://localhost:8500
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;api-a-3&#34;&gt;API A&lt;/h3&gt;

&lt;p&gt;Since we are using registrator to register the service, we need to disable the application service registration.&lt;/p&gt;

&lt;p&gt;server.json&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
  &amp;quot;description&amp;quot;: &amp;quot;server config&amp;quot;,
  &amp;quot;ip&amp;quot;: &amp;quot;0.0.0.0&amp;quot;,
  &amp;quot;port&amp;quot;: 7001,
  &amp;quot;serviceId&amp;quot;: &amp;quot;com.networknt.apia-1.0.0&amp;quot;,
  &amp;quot;enableRegistry&amp;quot;: false
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;cd ~/networknt/light-java-example/discovery/api_a/consuldocker
mvn clean install
docker build -t networknt/com.networknt.apia-1.0.0 .
docker run -it -p 7001:7001 --net=host --name=com.networknt.apia-1.0.0 networknt/com.networknt.apia-1.0.0
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;api-b-4&#34;&gt;API B&lt;/h3&gt;

&lt;p&gt;server.json&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
  &amp;quot;description&amp;quot;: &amp;quot;server config&amp;quot;,
  &amp;quot;ip&amp;quot;: &amp;quot;0.0.0.0&amp;quot;,
  &amp;quot;port&amp;quot;: 7002,
  &amp;quot;serviceId&amp;quot;: &amp;quot;com.networknt.apib-1.0.0&amp;quot;,
  &amp;quot;enableRegistry&amp;quot;: false
}

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;cd ~/networknt/light-java-example/discovery/api_b/consuldocker
mvn clean install
docker build -t networknt/com.networknt.apib-1.0.0 .
docker run -it -p 7002:7002 --net=host --name=com.networknt.apib-1.0.0 networknt/com.networknt.apib-1.0.0

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;api-c-3&#34;&gt;API C&lt;/h3&gt;

&lt;p&gt;server.json&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
  &amp;quot;description&amp;quot;: &amp;quot;server config&amp;quot;,
  &amp;quot;ip&amp;quot;: &amp;quot;0.0.0.0&amp;quot;,
  &amp;quot;port&amp;quot;: 7003,
  &amp;quot;serviceId&amp;quot;: &amp;quot;com.networknt.apic-1.0.0&amp;quot;,
  &amp;quot;enableRegistry&amp;quot;: false
}

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;cd ~/networknt/light-java-example/discovery/api_c/consuldocker
mvn clean install
docker build -t networknt/com.networknt.apic-1.0.0 .
docker run -it -p 7003:7003 --net=host --name=com.networknt.apic-1.0.0 networknt/com.networknt.apic-1.0.0

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;api-d-4&#34;&gt;API D&lt;/h3&gt;

&lt;p&gt;server.json&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
  &amp;quot;description&amp;quot;: &amp;quot;server config&amp;quot;,
  &amp;quot;ip&amp;quot;: &amp;quot;0.0.0.0&amp;quot;,
  &amp;quot;port&amp;quot;: 7004,
  &amp;quot;serviceId&amp;quot;: &amp;quot;com.networknt.apid-1.0.0&amp;quot;,
  &amp;quot;enableRegistry&amp;quot;: false
}

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;cd ~/networknt/light-java-example/discovery/api_d/consuldocker
mvn clean install
docker build -t networknt/com.networknt.apid-1.0.0 .
docker run -it -p 7004:7004 --net=host --name=com.networknt.apid-1.0.0 networknt/com.networknt.apid-1.0.0

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;test-servers-4&#34;&gt;Test Servers&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;curl http://localhost:7001/v1/data
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And here is the result.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[&amp;quot;API C: Message 1&amp;quot;,&amp;quot;API C: Message 2&amp;quot;,&amp;quot;API D: Message 1 from port 7004&amp;quot;,&amp;quot;API D: Message 2 from port 7004&amp;quot;,&amp;quot;API B: Message 1&amp;quot;,&amp;quot;API B: Message 2&amp;quot;,&amp;quot;API A: Message 1&amp;quot;,&amp;quot;API A: Message 2&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;kubernetes&#34;&gt;Kubernetes&lt;/h1&gt;
</description>
    </item>
    
    <item>
      <title>Tutorials</title>
      <link>https://networknt.github.io/light-java/tutorials/</link>
      <pubDate>Wed, 25 Jan 2017 20:59:08 -0500</pubDate>
      
      <guid>https://networknt.github.io/light-java/tutorials/</guid>
      <description>&lt;p&gt;The following tutorials will help users to get started and more will be added later.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://networknt.github.io/light-java/tutorials/microservices/&#34;&gt;How to build, test and deploy microserivces&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://networknt.github.io/light-java/tutorials/database/&#34;&gt;How to access database in microservices&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://networknt.github.io/light-java/tutorials/unit-test/&#34;&gt;How to do unit test&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://networknt.github.io/light-java/tutorials/end-to-end-test/&#34;&gt;How to do end-to-end test&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://networknt.github.io/light-java/tutorials/integration-test/&#34;&gt;How to do integration test&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://networknt.github.io/light-java/tutorials/debug/&#34;&gt;How to debug the service&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://networknt.github.io/light-java/tutorials/discovery/&#34;&gt;How to register and discover services&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Database Access Tutorial</title>
      <link>https://networknt.github.io/light-java/tutorials/database/</link>
      <pubDate>Mon, 23 Jan 2017 09:07:32 -0500</pubDate>
      
      <guid>https://networknt.github.io/light-java/tutorials/database/</guid>
      <description>

&lt;h1 id=&#34;introduction&#34;&gt;Introduction&lt;/h1&gt;

&lt;p&gt;Most microservices will have to access database in order to fulfill consumer requests.
In this tutorial, we will walk through the following steps with Oracle/Postgres/Mysql:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;How to setup database connection pool&lt;/li&gt;
&lt;li&gt;How to connect to the database instance&lt;/li&gt;
&lt;li&gt;How to do query database tables&lt;/li&gt;
&lt;li&gt;How to update database tables&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;preparation&#34;&gt;Preparation&lt;/h1&gt;

&lt;p&gt;In order to follow the steps below, please make sure you have the same working environment.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;A computer with MacOS or Linux (Windows should work but I never tried)&lt;/li&gt;
&lt;li&gt;Install git&lt;/li&gt;
&lt;li&gt;Install Docker&lt;/li&gt;
&lt;li&gt;Install JDK 8 and Maven&lt;/li&gt;
&lt;li&gt;Install Java IDE (Intellij IDEA Community Edition is recommended)&lt;/li&gt;
&lt;li&gt;Create a working directory under your user directory called networknt.&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;cd ~
mkdir networknt
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;create-database-demo-specification&#34;&gt;Create Database Demo Specification&lt;/h1&gt;

&lt;p&gt;First let&amp;rsquo;s build an OpenAPI specification with several endpoints to demo database
access. You will need &lt;a href=&#34;https://networknt.github.io/light-java/tools/swagger-editor/&#34;&gt;swagger editor&lt;/a&gt;
to create a specification.&lt;/p&gt;

&lt;p&gt;Here is the OpenAPI specification created and it can be found in
&lt;a href=&#34;https://github.com/networknt/swagger&#34;&gt;swagger repo&lt;/a&gt; database sub folder.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;swagger: &#39;2.0&#39;

info:
  version: &amp;quot;1.0.0&amp;quot;
  title: Light-Java-Rest Database Tutorial
  description: A demo on how to connect, query and update Oracle/Mysql/Postgres. 
  contact:
    email: stevehu@gmail.com
  license:
    name: &amp;quot;Apache 2.0&amp;quot;
    url: &amp;quot;http://www.apache.org/licenses/LICENSE-2.0.html&amp;quot;
host: database.networknt.com
schemes:
  - http
  - https
basePath: /v1

consumes:
  - application/json
produces:
  - application/json

paths:
  /query:
    get:
      description: Single query to database table
      operationId: getQuery
      responses:
        200:
          description: &amp;quot;successful operation&amp;quot;
          schema:
            $ref: &amp;quot;#/definitions/RandomNumber&amp;quot;          
      security:
      - database_auth:
        - &amp;quot;database.r&amp;quot;
  /queries:
    get:
      description: Multiple queries to database table
      operationId: getQueries
      parameters:
      - name: &amp;quot;queries&amp;quot;
        in: &amp;quot;query&amp;quot;
        description: &amp;quot;Number of random numbers&amp;quot;
        required: false
        type: &amp;quot;integer&amp;quot;
        format: &amp;quot;int32&amp;quot;
      responses:
        200:
          description: &amp;quot;successful operation&amp;quot;
          schema:
            type: &amp;quot;array&amp;quot;
            items:
              $ref: &amp;quot;#/definitions/RandomNumber&amp;quot;
      security:
      - database_auth:
        - &amp;quot;database.r&amp;quot;
  /updates:
    get:
      description: Multiple updates to database table
      operationId: getUpdates
      parameters:
      - name: &amp;quot;queries&amp;quot;
        in: &amp;quot;query&amp;quot;
        description: &amp;quot;Number of random numbers&amp;quot;
        required: false
        type: &amp;quot;integer&amp;quot;
        format: &amp;quot;int32&amp;quot;
      responses:
        200:
          description: &amp;quot;successful operation&amp;quot;
          schema:
            type: &amp;quot;array&amp;quot;
            items:
              $ref: &amp;quot;#/definitions/RandomNumber&amp;quot;
      security:
      - database_auth:
        - &amp;quot;database.w&amp;quot;
securityDefinitions:
  database_auth:
    type: &amp;quot;oauth2&amp;quot;
    authorizationUrl: &amp;quot;http://localhost:8888/oauth2/code&amp;quot;
    flow: &amp;quot;implicit&amp;quot;
    scopes:
      database.w: &amp;quot;write database table&amp;quot;
      database.r: &amp;quot;read database table&amp;quot;
definitions:
  RandomNumber:
    type: &amp;quot;object&amp;quot;
    required:
    - &amp;quot;id&amp;quot;
    - &amp;quot;randomNumber&amp;quot;
    properties:
      id:
        type: &amp;quot;integer&amp;quot;
        format: &amp;quot;int32&amp;quot;
        description: &amp;quot;a unique id as primary key&amp;quot;
      randomNumber:
        type: &amp;quot;integer&amp;quot;
        format: &amp;quot;int32&amp;quot;
        description: &amp;quot;a random number&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now let&amp;rsquo;s clone the swagger repo to your working directory.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd ~/networknt
git clone https://github.com/networknt/swagger
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;generate-demo-project&#34;&gt;Generate Demo Project&lt;/h1&gt;

&lt;p&gt;With the specification in place, we can generate the code with &lt;a href=&#34;https://github.com/networknt/swagger-codegen&#34;&gt;swagger-codegen&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;There are two different ways to generate the code:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Local build&lt;/li&gt;
&lt;li&gt;Docker container&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;To learn how to use the tool, please refer to this &lt;a href=&#34;tools/swagger-codegen/&#34;&gt;document&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;generate-code-with-local-build&#34;&gt;Generate code with local build&lt;/h3&gt;

&lt;p&gt;Clone and build swagger-codegen&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd ~/networknt
git clone git@github.com:networknt/swagger-codegen.git
cd swagger-codegen
mvn clean install -DskipTests
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For this demo, I am going to generate the code into light-java-example/database/generated
folder so that users can check the code later on from this repo.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s checkout the light-java-example repo and backup the existing database project.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd ~/networknt
git clone git@github.com:networknt/light-java-example.git
cd light-java-example
mv database database.bak
mkdir database
cd database
mkdir generated
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Before generating the project, we need to create a config.json to define packages,
artifactId and groupId for the project.&lt;/p&gt;

&lt;p&gt;Here is the content of the file and it can be found in ~/networknt/swagger/database&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
  &amp;quot;invokerPackage&amp;quot;: &amp;quot;com.networknt.database&amp;quot;,
  &amp;quot;apiPackage&amp;quot;:&amp;quot;com.networknt.database.handler&amp;quot;,
  &amp;quot;modelPackage&amp;quot;:&amp;quot;com.networknt.database.model&amp;quot;,
  &amp;quot;artifactId&amp;quot;: &amp;quot;database&amp;quot;,
  &amp;quot;groupId&amp;quot;: &amp;quot;com.networknt&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Code generation&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd ~/networknt/swagger-codegen
java -jar modules/swagger-codegen-cli/target/swagger-codegen-cli.jar generate -c ~/networknt/swagger/database/config.json -i ~/networknt/swagger/database/swagger.yaml -l light-java -o ~/networknt/light-java-example/database/generated

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now you should have a project generated. Let&amp;rsquo;s build it and run it.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd ~/networknt
cd light-java-example/database/generated
mvn clean install exec:exec
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now you can access the service with curl following the step below.&lt;/p&gt;

&lt;h3 id=&#34;generate-code-with-docker-container&#34;&gt;Generate code with docker container&lt;/h3&gt;

&lt;p&gt;Let&amp;rsquo;s remove the generated folder from light-java-example/database folder and
generate the project again with docker container.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd ~/networknt/light-java-example/database
rm -rf generated
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now let&amp;rsquo;s generate the project again with docker.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd ~/networknt
docker run -it -v ~/networknt/swagger/database:/swagger-api/swagger -v ~/networknt/light-java-example/database:/swagger-api/out networknt/swagger-codegen generate -c /swagger-api/swagger/config.json -i /swagger-api/swagger/swagger.yaml -l light-java -o /swagger-api/out/generated

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;rsquo;s build and start the service&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd ~/networknt/light-java-example/database/generated
mvn clean install exec:exec
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now you can access the service with curl following the next step.&lt;/p&gt;

&lt;h3 id=&#34;test-the-service&#34;&gt;Test the service&lt;/h3&gt;

&lt;p&gt;Now the service is up and running. Let&amp;rsquo;s access it from curl&lt;/p&gt;

&lt;p&gt;Single query&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;curl http://localhost:8080/v1/query

{  &amp;quot;randomNumber&amp;quot; : 123,  &amp;quot;id&amp;quot; : 123}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Multiple queries with default number of object returned&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;curl http://localhost:8080/v1/queries

[ {  &amp;quot;randomNumber&amp;quot; : 123,  &amp;quot;id&amp;quot; : 123} ]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Multiple queries with 10 numbers returned&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;curl http://localhost:8080/v1/queries?queries=10

[ {  &amp;quot;randomNumber&amp;quot; : 123,  &amp;quot;id&amp;quot; : 123} ]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Multiple updates with default number of object updated&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;curl http://localhost:8080/v1/updates

[ {  &amp;quot;randomNumber&amp;quot; : 123,  &amp;quot;id&amp;quot; : 123} ]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Multiple updates with 10 numbers updated&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;curl http://localhost:8080/v1/updates?queries=10

[ {  &amp;quot;randomNumber&amp;quot; : 123,  &amp;quot;id&amp;quot; : 123} ]
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;prepare-database-scripts&#34;&gt;Prepare Database Scripts&lt;/h1&gt;

&lt;p&gt;For database access, we are going to prepare three scripts for Oracle, Mysql and Postgres.&lt;/p&gt;

&lt;p&gt;Oracle&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;DROP TABLE world CASCADE CONSTRAINTS;
CREATE TABLE  world (
  id int NOT NULL,
  randomNumber int NOT NULL,
  PRIMARY KEY  (id)
);

BEGIN
FOR loop_counter IN 1..10000 LOOP
INSERT INTO world (id, randomNumber)
VALUES (loop_counter, dbms_random.value(1,10000)
       );
END LOOP;
COMMIT;
END;

DROP TABLE fortune CASCADE CONSTRAINTS;
CREATE TABLE fortune (
  id int NOT NULL,
  message varchar2(2048) NOT NULL,
  PRIMARY KEY  (id)
);

INSERT INTO fortune (id, message) VALUES (1, &#39;fortune: No such file or directory&#39;);
INSERT INTO fortune (id, message) VALUES (2, &#39;A computer scientist is someone who fixes things that aren&#39;&#39;t broken.&#39;);
INSERT INTO fortune (id, message) VALUES (3, &#39;After enough decimal places, nobody gives a damn.&#39;);
INSERT INTO fortune (id, message) VALUES (4, &#39;A bad random number generator: 1, 1, 1, 1, 1, 4.33e+67, 1, 1, 1&#39;);
INSERT INTO fortune (id, message) VALUES (5, &#39;A computer program does what you tell it to do, not what you want it to do.&#39;);
INSERT INTO fortune (id, message) VALUES (6, &#39;Emacs is a nice operating system, but I prefer UNIX.  Tom Christaensen&#39;);
INSERT INTO fortune (id, message) VALUES (7, &#39;Any program that runs right is obsolete.&#39;);
INSERT INTO fortune (id, message) VALUES (8, &#39;A list is only as strong as its weakest link.  Donald Knuth&#39;);
INSERT INTO fortune (id, message) VALUES (9, &#39;Feature: A bug with seniority.&#39;);
INSERT INTO fortune (id, message) VALUES (10, &#39;Computers make very fast, very accurate mistakes.&#39;);
INSERT INTO fortune (id, message) VALUES (11, &#39;&amp;lt;script&amp;gt;alert(&amp;quot;This should not be displayed in a browser alert box.&amp;quot;);&amp;lt;/script&amp;gt;&#39;);
INSERT INTO fortune (id, message) VALUES (12, &#39;&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Mysql&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# modified from SO answer http://stackoverflow.com/questions/5125096/for-loop-in-mysql
DROP DATABASE IF EXISTS hello_world;
CREATE DATABASE hello_world;
USE hello_world;

DROP TABLE IF EXISTS world;
CREATE TABLE  world (
  id int(10) unsigned NOT NULL auto_increment,
  randomNumber int NOT NULL default 0,
  PRIMARY KEY  (id)
)
ENGINE=INNODB;

DROP PROCEDURE IF EXISTS load_data;

DELIMITER #
CREATE PROCEDURE load_data()
BEGIN

declare v_max int unsigned default 10000;
declare v_counter int unsigned default 0;

  TRUNCATE TABLE world;
  START TRANSACTION;
  while v_counter &amp;lt; v_max do
    INSERT INTO world (randomNumber) VALUES ( floor(0 + (rand() * 10000)) );
    SET v_counter=v_counter+1;
  end while;
  commit;
END #

DELIMITER ;

CALL load_data();

DROP TABLE IF EXISTS fortune;
CREATE TABLE  fortune (
  id int(10) unsigned NOT NULL auto_increment,
  message varchar(2048) CHARACTER SET &#39;utf8&#39; NOT NULL,
  PRIMARY KEY  (id)
)
ENGINE=INNODB;

INSERT INTO fortune (message) VALUES (&#39;fortune: No such file or directory&#39;);
INSERT INTO fortune (message) VALUES (&#39;A computer scientist is someone who fixes things that aren&#39;&#39;t broken.&#39;);
INSERT INTO fortune (message) VALUES (&#39;After enough decimal places, nobody gives a damn.&#39;);
INSERT INTO fortune (message) VALUES (&#39;A bad random number generator: 1, 1, 1, 1, 1, 4.33e+67, 1, 1, 1&#39;);
INSERT INTO fortune (message) VALUES (&#39;A computer program does what you tell it to do, not what you want it to do.&#39;);
INSERT INTO fortune (message) VALUES (&#39;Emacs is a nice operating system, but I prefer UNIX.  Tom Christaensen&#39;);
INSERT INTO fortune (message) VALUES (&#39;Any program that runs right is obsolete.&#39;);
INSERT INTO fortune (message) VALUES (&#39;A list is only as strong as its weakest link.  Donald Knuth&#39;);
INSERT INTO fortune (message) VALUES (&#39;Feature: A bug with seniority.&#39;);
INSERT INTO fortune (message) VALUES (&#39;Computers make very fast, very accurate mistakes.&#39;);
INSERT INTO fortune (message) VALUES (&#39;&amp;lt;script&amp;gt;alert(&amp;quot;This should not be displayed in a browser alert box.&amp;quot;);&amp;lt;/script&amp;gt;&#39;);
INSERT INTO fortune (message) VALUES (&#39;&#39;);

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Postgres&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
DROP TABLE IF EXISTS world;
CREATE TABLE  world (
  id integer NOT NULL,
  randomNumber integer NOT NULL default 0,
  PRIMARY KEY  (id)
);

INSERT INTO world (id, randomnumber)
SELECT x.id, random() * 10000 + 1 FROM generate_series(1,10000) as x(id);

DROP TABLE IF EXISTS fortune;
CREATE TABLE fortune (
  id integer NOT NULL,
  message varchar(2048) NOT NULL,
  PRIMARY KEY  (id)
);

INSERT INTO fortune (id, message) VALUES (1, &#39;fortune: No such file or directory&#39;);
INSERT INTO fortune (id, message) VALUES (2, &#39;A computer scientist is someone who fixes things that aren&#39;&#39;t broken.&#39;);
INSERT INTO fortune (id, message) VALUES (3, &#39;After enough decimal places, nobody gives a damn.&#39;);
INSERT INTO fortune (id, message) VALUES (4, &#39;A bad random number generator: 1, 1, 1, 1, 1, 4.33e+67, 1, 1, 1&#39;);
INSERT INTO fortune (id, message) VALUES (5, &#39;A computer program does what you tell it to do, not what you want it to do.&#39;);
INSERT INTO fortune (id, message) VALUES (6, &#39;Emacs is a nice operating system, but I prefer UNIX.  Tom Christaensen&#39;);
INSERT INTO fortune (id, message) VALUES (7, &#39;Any program that runs right is obsolete.&#39;);
INSERT INTO fortune (id, message) VALUES (8, &#39;A list is only as strong as its weakest link.  Donald Knuth&#39;);
INSERT INTO fortune (id, message) VALUES (9, &#39;Feature: A bug with seniority.&#39;);
INSERT INTO fortune (id, message) VALUES (10, &#39;Computers make very fast, very accurate mistakes.&#39;);
INSERT INTO fortune (id, message) VALUES (11, &#39;&amp;lt;script&amp;gt;alert(&amp;quot;This should not be displayed in a browser alert box.&amp;quot;);&amp;lt;/script&amp;gt;&#39;);
INSERT INTO fortune (id, message) VALUES (12, &#39;&#39;);

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Above scripts can be found in &lt;a href=&#34;https://github.com/networknt/light-java-example/tree/master/database/dbscript&#34;&gt;https://github.com/networknt/light-java-example/tree/master/database/dbscript&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;start-databases&#34;&gt;Start Databases&lt;/h1&gt;

&lt;p&gt;In order to work on our service, we need to start database standalone for now. Depending
on which database you are working on, you can choose one of them below. For this demo
use mysql and later on we can switch to Postgres and Oracle.&lt;/p&gt;

&lt;p&gt;Oracle Database&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker run -v ~/networknt/light-java-example/database/dbscript/oracle:/docker-entrypoint-initdb.d -d -p 1522:1521 wnameless/oracle-xe-11g
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Mysql Database&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker run -v ~/networknt/light-java-example/database/dbscript/mysql:/docker-entrypoint-initdb.d -e MYSQL_ROOT_PASSWORD=my-secret-pw -d -p 3306:3306 mysql

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Postgres Database&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker run -v ~/networknt/light-java-example/database/dbscript/postgres:/docker-entrypoint-initdb.d -e POSTGRES_PASSWORD=my-secret-pw -e POSTGRES_DB=hello_world -d -p 5432:5432 postgres

&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;setup-connection-pool&#34;&gt;Setup Connection Pool&lt;/h1&gt;

&lt;p&gt;To connect to database we need to create service.json that can inject connection pool
to the microservice you are building.&lt;/p&gt;

&lt;p&gt;Now we have generated project, let&amp;rsquo;s copy it and update with db connection pool&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd ~/networknt/light-java-example/database
cp -r generated connection
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Add the following service.json to ~/networknt/light-java-example/database/connection/src/main/resources/config&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
  &amp;quot;description&amp;quot;: &amp;quot;singleton service factory configuration&amp;quot;,
  &amp;quot;singletons&amp;quot;: [
    {
      &amp;quot;javax.sql.DataSource&amp;quot;: [
        {
          &amp;quot;com.zaxxer.hikari.HikariDataSource&amp;quot;:
          {
            &amp;quot;jdbcUrl&amp;quot;: &amp;quot;jdbc:mysql://localhost:3306/hello_world?useSSL=false&amp;quot;,
            &amp;quot;username&amp;quot;: &amp;quot;root&amp;quot;,
            &amp;quot;password&amp;quot;: &amp;quot;my-secret-pw&amp;quot;,
            &amp;quot;maximumPoolSize&amp;quot;: 95,
            &amp;quot;useServerPrepStmts&amp;quot;: true,
            &amp;quot;cachePrepStmts&amp;quot;: true,
            &amp;quot;cacheCallableStmts&amp;quot;: true,
            &amp;quot;prepStmtCacheSize&amp;quot;: 4096,
            &amp;quot;prepStmtCacheSqlLimit&amp;quot;: 2048
          }
        }
      ]
    }
  ]
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The service.json will make sure the a Hikari DataSource will be created during server startup
with the dependency injection module. You can find other database&amp;rsquo;s service.json in
&lt;a href=&#34;https://github.com/networknt/light-java-example/tree/master/database/dbscript&#34;&gt;https://github.com/networknt/light-java-example/tree/master/database/dbscript&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;In order to do that we need to add several jars into the dependency in pom.xml&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        &amp;lt;version.hikaricp&amp;gt;2.5.1&amp;lt;/version.hikaricp&amp;gt;
        &amp;lt;version.fastscanner&amp;gt;2.0.8&amp;lt;/version.fastscanner&amp;gt;
        &amp;lt;version.h2&amp;gt;1.3.176&amp;lt;/version.h2&amp;gt;
        &amp;lt;version.hazelcast&amp;gt;3.6.7&amp;lt;/version.hazelcast&amp;gt;
        &amp;lt;version.oracle&amp;gt;11.2.0.3&amp;lt;/version.oracle&amp;gt;
        &amp;lt;version.mysql&amp;gt;6.0.4&amp;lt;/version.mysql&amp;gt;
        &amp;lt;version.postgres&amp;gt;9.4.1211&amp;lt;/version.postgres&amp;gt;


        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;com.zaxxer&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;HikariCP&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;${version.hikaricp}&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;io.github.lukehutch&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;fast-classpath-scanner&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;${version.fastscanner}&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;com.oracle&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;ojdbc6&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;${version.oracle}&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;mysql&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;mysql-connector-java&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;${version.mysql}&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.postgresql&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;postgresql&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;${version.postgres}&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now you can add a line in each handler to get the DataSource as a static variable.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    private static final DataSource ds = (DataSource) SingletonServiceFactory.getBean(DataSource.class);

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you can build, start and access the server with curl, that means the database connection
is created. The next step we will try to query from database.&lt;/p&gt;

&lt;h1 id=&#34;single-database-query&#34;&gt;Single Database Query&lt;/h1&gt;

&lt;p&gt;Let&amp;rsquo;s copy connection to query&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd ~/networknt/light-java-example/database
cp -r connection query

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And let&amp;rsquo;s update QueryGetHandler.java&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package com.networknt.database.handler;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.networknt.config.Config;
import com.networknt.database.model.RandomNumber;
import com.networknt.service.SingletonServiceFactory;
import io.undertow.server.HttpHandler;
import io.undertow.server.HttpServerExchange;
import io.undertow.util.Headers;

import javax.sql.DataSource;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.util.Map;
import java.util.concurrent.Callable;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.Future;

public class QueryGetHandler implements HttpHandler {
    private static final DataSource ds = (DataSource) SingletonServiceFactory.getBean(DataSource.class);
    private static final ObjectMapper mapper = Config.getInstance().getMapper();

    @Override
    public void handleRequest(HttpServerExchange exchange) throws Exception {
        if (exchange.isInIoThread()) {
            exchange.dispatch(this);
            return;
        }
        int queries = 1;

        RandomNumber[] randomNumbers = new RandomNumber[queries];
        try (final Connection connection = ds.getConnection()) {
            Map&amp;lt;Integer, Future&amp;lt;RandomNumber&amp;gt;&amp;gt; futureWorlds = new ConcurrentHashMap&amp;lt;&amp;gt;();
            for (int i = 0; i &amp;lt; queries; i++) {
                futureWorlds.put(i, Helper.EXECUTOR.submit(new Callable&amp;lt;RandomNumber&amp;gt;(){
                    @Override
                    public RandomNumber call() throws Exception {
                        try (PreparedStatement statement = connection.prepareStatement(
                                &amp;quot;SELECT * FROM world WHERE id = ?&amp;quot;,
                                ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY)) {

                            statement.setInt(1, Helper.randomWorld());
                            ResultSet resultSet = statement.executeQuery();
                            resultSet.next();
                            return new RandomNumber(
                                    resultSet.getInt(&amp;quot;id&amp;quot;),
                                    resultSet.getInt(&amp;quot;randomNumber&amp;quot;));
                        }
                    }
                }));
            }

            for (int i = 0; i &amp;lt; queries; i++) {
                randomNumbers[i] = futureWorlds.get(i).get();
            }
        }
        exchange.getResponseHeaders().put(
                Headers.CONTENT_TYPE, &amp;quot;application/json&amp;quot;);

        exchange.getResponseSender().send(mapper.writeValueAsString(randomNumbers[0]));
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And add a helper class Helper.java&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package com.networknt.database.handler;

import io.undertow.server.HttpServerExchange;

import java.util.Deque;
import java.util.concurrent.*;

/**
 * Created by stevehu on 2017-01-23.
 */
public class Helper {
    private Helper() {
        throw new AssertionError();
    }

    /**
     * Returns the value of the &amp;quot;queries&amp;quot; request parameter, which is an integer
     * bound between 1 and 500 with a default value of 1.
     *
     * @param exchange the current HTTP exchange
     * @return the value of the &amp;quot;queries&amp;quot; request parameter
     */
    static int getQueries(HttpServerExchange exchange) {
        Deque&amp;lt;String&amp;gt; values = exchange.getQueryParameters().get(&amp;quot;queries&amp;quot;);
        if (values == null) {
            return 1;
        }
        String textValue = values.peekFirst();
        if (textValue == null) {
            return 1;
        }
        try {
            int parsedValue = Integer.parseInt(textValue);
            return Math.min(500, Math.max(1, parsedValue));
        } catch (NumberFormatException e) {
            return 1;
        }
    }

    /**
     * Returns a random integer that is a suitable value for both the {@code id}
     * and {@code randomNumber} properties of a world object.
     *
     * @return a random world number
     */
    static int randomWorld() {
        return 1 + ThreadLocalRandom.current().nextInt(10000);
    }

    private static final int cpuCount = Runtime.getRuntime().availableProcessors();

    // todo: parameterize multipliers
    public static ExecutorService EXECUTOR =
            new ThreadPoolExecutor(
                    cpuCount * 2, cpuCount * 25, 200, TimeUnit.MILLISECONDS,
                    new LinkedBlockingQueue&amp;lt;Runnable&amp;gt;(cpuCount * 100),
                    new ThreadPoolExecutor.CallerRunsPolicy());

}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And add a constructor that accept two integer as parameters for RandomNumber.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  public RandomNumber(int id, int randomNumber) {
    this.id = id;
    this.randomNumber = randomNumber;
  }

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We are good to go.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd ~/networknt/light-java-example/database/query
mvn clean install exec:exec
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Access the query endpoint and you will result the random number as result.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;curl http://localhost:8080/v1/query

{&amp;quot;id&amp;quot;:4495,&amp;quot;randomNumber&amp;quot;:6569}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;multiple-database-queries&#34;&gt;Multiple Database Queries&lt;/h1&gt;

&lt;p&gt;Let&amp;rsquo;s build multiple queries based on the codebase of single query.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd ~/networknt/light-java-example/database
cp -r query queries
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now let&amp;rsquo;s update queries project for QueriesGetHandler.java&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package com.networknt.database.handler;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.networknt.config.Config;
import com.networknt.database.model.RandomNumber;
import com.networknt.service.SingletonServiceFactory;
import io.undertow.server.HttpHandler;
import io.undertow.server.HttpServerExchange;
import io.undertow.util.Headers;
import io.undertow.util.HttpString;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.Callable;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.Future;

import org.apache.commons.lang3.StringEscapeUtils;

import javax.sql.DataSource;

public class QueriesGetHandler implements HttpHandler {
    private static final DataSource ds = (DataSource) SingletonServiceFactory.getBean(DataSource.class);
    private static final ObjectMapper mapper = Config.getInstance().getMapper();

    @Override
    public void handleRequest(HttpServerExchange exchange) throws Exception {
        if (exchange.isInIoThread()) {
            exchange.dispatch(this);
            return;
        }
        int queries = Helper.getQueries(exchange);

        RandomNumber[] randomNumbers = new RandomNumber[queries];
        try (final Connection connection = ds.getConnection()) {
            Map&amp;lt;Integer, Future&amp;lt;RandomNumber&amp;gt;&amp;gt; futureWorlds = new ConcurrentHashMap&amp;lt;&amp;gt;();
            for (int i = 0; i &amp;lt; queries; i++) {
                futureWorlds.put(i, Helper.EXECUTOR.submit(new Callable&amp;lt;RandomNumber&amp;gt;(){
                    @Override
                    public RandomNumber call() throws Exception {
                        try (PreparedStatement statement = connection.prepareStatement(
                                &amp;quot;SELECT * FROM world WHERE id = ?&amp;quot;,
                                ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY)) {

                            statement.setInt(1, Helper.randomWorld());
                            ResultSet resultSet = statement.executeQuery();
                            resultSet.next();
                            return new RandomNumber(
                                    resultSet.getInt(&amp;quot;id&amp;quot;),
                                    resultSet.getInt(&amp;quot;randomNumber&amp;quot;));
                        }
                    }
                }));
            }

            for (int i = 0; i &amp;lt; queries; i++) {
                randomNumbers[i] = futureWorlds.get(i).get();
            }
        }
        exchange.getResponseHeaders().put(
                Headers.CONTENT_TYPE, &amp;quot;application/json&amp;quot;);
        exchange.getResponseSender().send(mapper.writeValueAsString(randomNumbers));
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now let&amp;rsquo;s build and test the server&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd ~/networknt/light-java-example/database/queries
mvn clean install exec:exec
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;rsquo;s test it.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;curl http://localhost:8080/v1/queries
[{&amp;quot;id&amp;quot;:1480,&amp;quot;randomNumber&amp;quot;:4720}]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Again with 10 random numbers&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;curl http://localhost:8080/v1/queries?queries=10

[{&amp;quot;id&amp;quot;:4473,&amp;quot;randomNumber&amp;quot;:2370},{&amp;quot;id&amp;quot;:1142,&amp;quot;randomNumber&amp;quot;:3999},{&amp;quot;id&amp;quot;:6022,&amp;quot;randomNumber&amp;quot;:1683},{&amp;quot;id&amp;quot;:159,&amp;quot;randomNumber&amp;quot;:4017},{&amp;quot;id&amp;quot;:8512,&amp;quot;randomNumber&amp;quot;:3248},{&amp;quot;id&amp;quot;:4291,&amp;quot;randomNumber&amp;quot;:620},{&amp;quot;id&amp;quot;:3238,&amp;quot;randomNumber&amp;quot;:1257},{&amp;quot;id&amp;quot;:8524,&amp;quot;randomNumber&amp;quot;:256},{&amp;quot;id&amp;quot;:7869,&amp;quot;randomNumber&amp;quot;:1709},{&amp;quot;id&amp;quot;:6410,&amp;quot;randomNumber&amp;quot;:9362}]
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;update-database&#34;&gt;Update Database&lt;/h1&gt;

&lt;p&gt;Let&amp;rsquo;s copy the queries to updates in order to work on updates&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd ~/networknt/light-java-example/database
cp -r queries updates
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now let&amp;rsquo;s update UpdatesGetHandler.java in updates folder.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package com.networknt.database.handler;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.networknt.config.Config;
import com.networknt.database.model.RandomNumber;
import com.networknt.service.SingletonServiceFactory;
import io.undertow.server.HttpHandler;
import io.undertow.server.HttpServerExchange;
import io.undertow.util.Headers;
import io.undertow.util.HttpString;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.Callable;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.Future;

import org.apache.commons.lang3.StringEscapeUtils;

import javax.sql.DataSource;

public class UpdatesGetHandler implements HttpHandler {
    private static final DataSource ds = (DataSource) SingletonServiceFactory.getBean(DataSource.class);
    private static final ObjectMapper mapper = Config.getInstance().getMapper();

    @Override
    public void handleRequest(HttpServerExchange exchange) throws Exception {
        if (exchange.isInIoThread()) {
            exchange.dispatch(this);
            return;
        }
        int queries = Helper.getQueries(exchange);
        RandomNumber[] worlds = new RandomNumber[queries];
        try (final Connection connection = ds.getConnection()) {
            Map&amp;lt;Integer, Future&amp;lt;RandomNumber&amp;gt;&amp;gt; futureWorlds = new ConcurrentHashMap&amp;lt;&amp;gt;();
            for (int i = 0; i &amp;lt; queries; i++) {
                futureWorlds.put(i, Helper.EXECUTOR.submit(new Callable&amp;lt;RandomNumber&amp;gt;() {
                    @Override
                    public RandomNumber call() throws Exception {
                        RandomNumber rn;
                        try (PreparedStatement update = connection.prepareStatement(
                                &amp;quot;UPDATE world SET randomNumber = ? WHERE id= ?&amp;quot;)) {
                            try (PreparedStatement query = connection.prepareStatement(
                                    &amp;quot;SELECT * FROM world WHERE id = ?&amp;quot;,
                                    ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY)) {

                                query.setInt(1, Helper.randomWorld());
                                ResultSet resultSet = query.executeQuery();
                                resultSet.next();
                                rn = new RandomNumber(
                                        resultSet.getInt(&amp;quot;id&amp;quot;),
                                        resultSet.getInt(&amp;quot;randomNumber&amp;quot;));
                            }
                            rn.setRandomNumber(Helper.randomWorld());
                            update.setInt(1, rn.getRandomNumber());
                            update.setInt(2, rn.getId());
                            update.executeUpdate();
                            return rn;
                        }
                    }
                }));
            }
            for (int i = 0; i &amp;lt; queries; i++) {
                worlds[i] = futureWorlds.get(i).get();
            }
        }
        exchange.getResponseHeaders().put(
                Headers.CONTENT_TYPE, &amp;quot;application/json&amp;quot;);
        exchange.getResponseSender().send(mapper.writeValueAsString(worlds));
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;rsquo;s build and start the server&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd ~/networknt/light-java-example/database/updates
mvn clean install exec:exec

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;rsquo;s test it with one update&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;curl http://localhost:8080/v1/updates

[{&amp;quot;id&amp;quot;:4682,&amp;quot;randomNumber&amp;quot;:1717}]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;rsquo;s test it with multiple updates&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;curl http://localhost:8080/v1/updates?queries=10

[{&amp;quot;id&amp;quot;:6395,&amp;quot;randomNumber&amp;quot;:938},{&amp;quot;id&amp;quot;:4124,&amp;quot;randomNumber&amp;quot;:4406},{&amp;quot;id&amp;quot;:7694,&amp;quot;randomNumber&amp;quot;:936},{&amp;quot;id&amp;quot;:502,&amp;quot;randomNumber&amp;quot;:5784},{&amp;quot;id&amp;quot;:6992,&amp;quot;randomNumber&amp;quot;:8037},{&amp;quot;id&amp;quot;:3607,&amp;quot;randomNumber&amp;quot;:3462},{&amp;quot;id&amp;quot;:6910,&amp;quot;randomNumber&amp;quot;:6195},{&amp;quot;id&amp;quot;:7388,&amp;quot;randomNumber&amp;quot;:9233},{&amp;quot;id&amp;quot;:6235,&amp;quot;randomNumber&amp;quot;:4825},{&amp;quot;id&amp;quot;:4924,&amp;quot;randomNumber&amp;quot;:1066}]
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;switch-to-postgres&#34;&gt;Switch to Postgres&lt;/h1&gt;

&lt;p&gt;The first step is to start the postgres database in docker. The command
has shown above.&lt;/p&gt;

&lt;p&gt;To switch to Postgres database, you just need to replace server.json from
dbscript/postgres/config folder. First let&amp;rsquo;s create a new folder from
updates and modify the service.json&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd ~/networknt/light-java-example/database
cp -r updates postgres
cp dbscript/postgres/config/service.json postgres/src/main/resources/config
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now let&amp;rsquo;s build the server from postgres folder.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd postgres
mvn clean install exec:exec
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now you can test the server with curl to verify that the server is working with
Postgres database.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;curl http://localhost:8080/v1/query
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;switch-to-oracle&#34;&gt;Switch to Oracle&lt;/h1&gt;

&lt;p&gt;The first step is to start Oracle database in docker. The command has
shown above.&lt;/p&gt;

&lt;p&gt;Next we need to add a repo into pom.xml as Oracle client jar is not in
maven central due to licensing issue.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    &amp;lt;repositories&amp;gt;
        &amp;lt;!-- Repository for ORACLE ojdbc6. --&amp;gt;
        &amp;lt;repository&amp;gt;
            &amp;lt;id&amp;gt;codelds&amp;lt;/id&amp;gt;
            &amp;lt;url&amp;gt;https://code.lds.org/nexus/content/groups/main-repo&amp;lt;/url&amp;gt;
        &amp;lt;/repository&amp;gt;
    &amp;lt;/repositories&amp;gt;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To switch to Oracle database, you just need to replace server.json from
dbscript/oracle/config folder. First let&amp;rsquo;s create a new folder from
updates and modify the service.json&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd ~/networknt/light-java-example/database
cp -r updates oracle
cp dbscript/oracle/config/service.json oracle/src/main/resources/config
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now let&amp;rsquo;s build the server from postgres folder.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd oracle
mvn clean install exec:exec
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now you can test the server with curl to verify that the server is working with
Oracle database.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;curl http://localhost:8080/v1/query
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;end-to-end-test&#34;&gt;End-to-End Test&lt;/h1&gt;

&lt;p&gt;In this step, we are going to create some end-to-end test cases. As these tests
are very important in ensuring the server you build works. They give us confidence
on changing the code and support continuous integration to production.&lt;/p&gt;

&lt;p&gt;Given our code is based on a light weight Http framework, all our tests will be
using the real server. There is a TestServer.java in the generated code already
and each handler will have a generated test case. The only thing we need to do
is to add testing logic.&lt;/p&gt;

&lt;p&gt;First let&amp;rsquo;s create a new folder call test from updates which is using Mysql.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd ~/networknt/light-java-example/database
cp -r updates test
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now let&amp;rsquo;s go to IDE and navigate to the test folder under src. You can find there
are three test cases for each handler and there is an extra class called
TestServer.java&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s take a look at the generated QueryGetHandlerTest.java&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package com.networknt.database.handler;

import com.networknt.client.Client;
import com.networknt.server.Server;
import com.networknt.exception.ClientException;
import com.networknt.exception.ApiException;
import org.apache.commons.io.IOUtils;
import org.apache.http.HttpResponse;
import org.apache.http.client.ClientProtocolException;
import org.apache.http.client.ResponseHandler;
import org.apache.http.client.methods.*;
import org.apache.http.impl.client.CloseableHttpClient;
import org.junit.*;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.IOException;

/**
* Generated by swagger-codegen
*/
public class QueryGetHandlerTest {
    @ClassRule
    public static TestServer server = TestServer.getInstance();

    static final Logger logger = LoggerFactory.getLogger(QueryGetHandlerTest.class);

    @Test
    public void testQueryGetHandler() throws ClientException, ApiException {
        CloseableHttpClient client = Client.getInstance().getSyncClient();
        HttpGet httpGet = new HttpGet(&amp;quot;http://localhost:8080/v1/query&amp;quot;);
        /*
        Client.getInstance().addAuthorization(httpPost);
        try {
            CloseableHttpResponse response = client.execute(httpGet);
            Assert.assertEquals(200, response.getStatusLine().getStatusCode());
            Assert.assertEquals(&amp;quot;getQuery&amp;quot;, IOUtils.toString(response.getEntity().getContent(), &amp;quot;utf8&amp;quot;));
        } catch (Exception e) {
            e.printStackTrace();
        }
        */
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In this test file, we can see that a static TestServer instance is started
with @ClassRule to be shared by all test cases in this test file. Also, there
is one test case with some of the logic commented out. This test is a positive
test generated based on swagger specification. The result checking code
is commented out because we don&amp;rsquo;t know what is the exact object returned.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s modify it to make it work in our service that is connecting to Mysql.
Later on, we are going to remove Mysql dependency with H2 database embedded.&lt;/p&gt;

&lt;h1 id=&#34;performance-test&#34;&gt;Performance Test&lt;/h1&gt;

&lt;p&gt;To test the endpoint on your localhost, use the following command. You cannot
use localhost, so you have to find out your ip address.&lt;/p&gt;

&lt;p&gt;You can use ifconfig to find you local ip.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker run --rm williamyeh/wrk -t4 -c50 -d30s --timeout 2s http://192.168.1.131:8080/v1/query
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here is the result.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Running 30s test @ http://192.168.1.131:8080/v1/query
  4 threads and 50 connections
  Thread Stats   Avg      Stdev     Max   +/- Stdev
    Latency    10.30ms    3.78ms  74.03ms   89.91%
    Req/Sec     1.18k   160.15     1.86k    72.50%
  141321 requests in 30.05s, 20.73MB read
Requests/sec:   4703.17
Transfer/sec:    706.30KB
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As we are using Mysql docker container and its maximum connection can only reach 100.
If you can increase the connection pool size, you can get even better performance.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>End to End Test</title>
      <link>https://networknt.github.io/light-java/tutorials/end-to-end-test/</link>
      <pubDate>Wed, 12 Oct 2016 17:21:40 -0400</pubDate>
      
      <guid>https://networknt.github.io/light-java/tutorials/end-to-end-test/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Integration Test</title>
      <link>https://networknt.github.io/light-java/tutorials/integration-test/</link>
      <pubDate>Wed, 12 Oct 2016 17:06:30 -0400</pubDate>
      
      <guid>https://networknt.github.io/light-java/tutorials/integration-test/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Unit Test</title>
      <link>https://networknt.github.io/light-java/tutorials/unit-test/</link>
      <pubDate>Wed, 12 Oct 2016 17:05:47 -0400</pubDate>
      
      <guid>https://networknt.github.io/light-java/tutorials/unit-test/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Debug</title>
      <link>https://networknt.github.io/light-java/tutorials/debug/</link>
      <pubDate>Wed, 12 Oct 2016 17:03:28 -0400</pubDate>
      
      <guid>https://networknt.github.io/light-java/tutorials/debug/</guid>
      <description>&lt;p&gt;As there is no container in Undertow Server and everything is built on top of POJO, it
is very easy to debug your API application within your IDE.&lt;/p&gt;

&lt;p&gt;I am using Intellij Idea but Eclipse should be very similar as the generated project is
standard Maven project. To debug your code, you need to start the server.&lt;/p&gt;

&lt;p&gt;Here is the steps to create a standalone application in Idea.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Click Run and select Edit Configurations&amp;hellip;&lt;/li&gt;
&lt;li&gt;Click + on the top left corner to add a new Configuration.&lt;/li&gt;
&lt;li&gt;In the dropdown select application&lt;/li&gt;
&lt;li&gt;Name your application to Server&lt;/li&gt;
&lt;li&gt;In Main Class input, type com.networknt.server.Server&lt;/li&gt;
&lt;li&gt;Click apply to close the popup window.&lt;/li&gt;
&lt;li&gt;Click Run again and select debug&lt;/li&gt;
&lt;li&gt;Pick the application configuration you just created.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Now the server is up and running in the debug mode. You can debug into the framework
code or set a break point in framework code. To pick up the framework class to debug,
click External Libraries on the Project tree and click the class name. Idea will
automatically decompile the class. You can import the source code of that particular
version of framework source code from &lt;a href=&#34;https://github.com/networknt/light-java/releases&#34;&gt;Release&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Chain Pattern Microservices</title>
      <link>https://networknt.github.io/light-java/tutorials/ms_chain/</link>
      <pubDate>Sun, 09 Oct 2016 08:01:56 -0400</pubDate>
      
      <guid>https://networknt.github.io/light-java/tutorials/ms_chain/</guid>
      <description>

&lt;h2 id=&#34;introduction&#34;&gt;Introduction&lt;/h2&gt;

&lt;p&gt;These days light weight container like Docker is getting traction, more and more
API services are developed for docker container and deployed to the cloud. In this
environment, traditional heavy weight containers like Java EE and Spring are
losing ground as it doesn&amp;rsquo;t make sense to have a heavy weight container wrapped
with a light weight docker container. Docker and container orchestration tools
like Kubernetes and Docker Swarm are replacing all the functionalities Java EE
provides without hogging resources.&lt;/p&gt;

&lt;p&gt;There is an &lt;a href=&#34;https://www.gartner.com/doc/reprints?id=1-3N8E378&amp;amp;ct=161205&amp;amp;st=sb&#34;&gt;article&lt;/a&gt;
published by Gartner indicates that both Java EE and .NET are declining and will
be replaced very soon.&lt;/p&gt;

&lt;p&gt;Another clear trend is standalone Gateway is phasing out in the cloud environment
with docker containers as most of the traditional gateway features are replaced
by container orchestration tool and docker container management tools. In addition,
some of the cross cutting concerns gateway provided are addressed in API frameworks
like Light-Java.&lt;/p&gt;

&lt;p&gt;This tutorial shows you how to build 4 services chained together one by one. And it will
be the foundation for our microserives benchmarks.&lt;/p&gt;

&lt;p&gt;API A -&amp;gt; API B -&amp;gt; API C -&amp;gt; API D&lt;/p&gt;

&lt;h2 id=&#34;prepare-workspace&#34;&gt;Prepare workspace&lt;/h2&gt;

&lt;p&gt;All specifications and code of the services are on github.com but we are going to
redo it again by following the steps in the tutorial. Let&amp;rsquo;s first create a
workspace. I have created a directory named networknt under user directory.&lt;/p&gt;

&lt;p&gt;Checkout related projects.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd ~/networknt
git clone git@github.com:networknt/swagger-codegen.git
git clone git@github.com:networknt/light-java-example.git
git clone git@github.com:networknt/swagger.git
git clone git@github.com:networknt/light-oauth2.git
git clone git@github.com:networknt/light-docker.git

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As we are going to regenerate API A, B, C and D, let&amp;rsquo;s rename ms_chain folder from
light-java-example.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd ~/networknt/light-java-example
mv ms_chain ms_chain.bak
cd ..
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;specifications&#34;&gt;Specifications&lt;/h2&gt;

&lt;p&gt;Light Java Microservices Framework encourages Design Driven API building and
&lt;a href=&#34;https://github.com/OAI/OpenAPI-Specification&#34;&gt;OpenAPI Specification&lt;/a&gt; is the central
piece to drive the runtime for security and validation. Also, the specification
can be used to scaffold a running server project the first time so that developers
can focus their efforts on the domain business logic implementation without
worrying about how each component wired together.&lt;/p&gt;

&lt;p&gt;During the service implementation phase, specification might be changed and you can
regenerate the service codebase again without overwriting your handlers and test
cases for handlers.&lt;/p&gt;

&lt;p&gt;To create swagger specification, the best tool is
&lt;a href=&#34;http://swagger.io/swagger-editor/&#34;&gt;swagger-editor&lt;/a&gt; and I have an
&lt;a href=&#34;https://networknt.github.io/light-java/tools/swagger-editor/&#34;&gt;article&lt;/a&gt;
in tools section to describe how to use it.&lt;/p&gt;

&lt;p&gt;By following the &lt;a href=&#34;https://networknt.github.io/light-java/tools/swagger-editor/&#34;&gt;instructions&lt;/a&gt;
on how to use the editor, let&amp;rsquo;s create four API specifications in swagger repo.&lt;/p&gt;

&lt;p&gt;API A will call API B, API B will call API C, API C will call API D&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;API A -&amp;gt; API B -&amp;gt; API C -&amp;gt; API D
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here is the API A swagger.yaml and others can be found at
&lt;a href=&#34;https://github.com/networknt/swagger&#34;&gt;https://github.com/networknt/swagger&lt;/a&gt; or swagger
folder in your workspace.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;swagger: &#39;2.0&#39;

info:
  version: &amp;quot;1.0.0&amp;quot;
  title: API A for microservices demo
  description: API A is called by consumer directly and it will call API B and API C to get data
  contact:
    email: stevehu@gmail.com
  license:
    name: &amp;quot;Apache 2.0&amp;quot;
    url: &amp;quot;http://www.apache.org/licenses/LICENSE-2.0.html&amp;quot;
host: a.networknt.com
schemes:
  - http
basePath: /v1

consumes:
  - application/json
produces:
  - application/json

paths:
  /data:
    get:
      description: Return an array of strings collected from down stream APIs
      operationId: listData
      responses:
        200:
          description: Successful response
          schema:
            title: ArrayOfStrings
            type: array
            items:
              type: string
      security:
        - a_auth:
          - api_a.w
          - api_a.r

securityDefinitions:
  a_auth:
    type: oauth2
    authorizationUrl: http://localhost:8080/oauth2/code
    flow: implicit
    scopes:
      api_a.w: write access
      api_a.r: read access
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As defined in the specification, API A will return a list of stings and it requires
scope api_a.r or scope api_a.w to access the endpoint /data.&lt;/p&gt;

&lt;h2 id=&#34;swagger-codegen&#34;&gt;Swagger-Codegen&lt;/h2&gt;

&lt;p&gt;Now we have four API swagger.yaml files available. Let&amp;rsquo;s use swagger-codegen
to start four projects in light-java-example/ms_chain. In normal API build, you
should create a repo for each API.&lt;/p&gt;

&lt;h4 id=&#34;build-light-java-generator&#34;&gt;Build Light Java Generator&lt;/h4&gt;

&lt;p&gt;As &lt;a href=&#34;https://github.com/swagger-api/swagger-codegen&#34;&gt;swagger-codegen&lt;/a&gt; doesn&amp;rsquo;t
support Java 8, I have forked it &lt;a href=&#34;https://github.com/networknt/swagger-codegen&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The project is cloned to the local already during the prepare stage. Let&amp;rsquo;s build it.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd swagger-codegen
mvn clean install -DskipTests
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;generate-first-project&#34;&gt;Generate first project&lt;/h4&gt;

&lt;p&gt;Now you have your swagger-codegen built, let&amp;rsquo;s generate a project. Assume that
swagger, light-java-example and swagger-codegen are in the same working
directory ~/networknt and you are in ~/networknt/swagger-codegen now.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;java -jar modules/swagger-codegen-cli/target/swagger-codegen-cli.jar generate -i ../swagger/api_a/swagger.yaml -l light-java -o ../light-java-example/ms_chain/api_a/generated

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here is the generator output.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[main] INFO io.swagger.parser.Swagger20Parser - reading from ../swagger/api_a/swagger.yaml
[main] WARN io.swagger.codegen.DefaultCodegen - Empty operationId found for path: get /server/info. Renamed to auto-generated operationId: serverInfoGet
[main] INFO io.swagger.codegen.AbstractGenerator - writing file /Users/stevehu/networknt/swagger-codegen/../light-java-example/ms_chain/api_a/generated/src/main/java/io/swagger/handler/DataGetHandler.java
[main] INFO io.swagger.codegen.AbstractGenerator - writing file /Users/stevehu/networknt/swagger-codegen/../light-java-example/ms_chain/api_a/generated/src/test/java/io/swagger/handler/DataGetHandlerTest.java
[main] INFO io.swagger.codegen.AbstractGenerator - writing file /Users/stevehu/networknt/swagger-codegen/../light-java-example/ms_chain/api_a/generated/src/main/java/io/swagger/handler/ServerInfoGetHandler.java
[main] INFO io.swagger.codegen.AbstractGenerator - writing file /Users/stevehu/networknt/swagger-codegen/../light-java-example/ms_chain/api_a/generated/src/test/java/io/swagger/handler/ServerInfoGetHandlerTest.java
swaggerio.swagger.models.Swagger@dc2e0c3c
[main] INFO io.swagger.codegen.AbstractGenerator - writing file /Users/stevehu/networknt/swagger-codegen/../light-java-example/ms_chain/api_a/generated/pom.xml
[main] INFO io.swagger.codegen.AbstractGenerator - writing file /Users/stevehu/networknt/swagger-codegen/../light-java-example/ms_chain/api_a/generated/README.md
[main] INFO io.swagger.codegen.AbstractGenerator - writing file /Users/stevehu/networknt/swagger-codegen/../light-java-example/ms_chain/api_a/generated/.gitignore
[main] INFO io.swagger.codegen.AbstractGenerator - writing file /Users/stevehu/networknt/swagger-codegen/../light-java-example/ms_chain/api_a/generated/Dockerfile
[main] INFO io.swagger.codegen.AbstractGenerator - writing file /Users/stevehu/networknt/swagger-codegen/../light-java-example/ms_chain/api_a/generated/.classpath
[main] INFO io.swagger.codegen.AbstractGenerator - writing file /Users/stevehu/networknt/swagger-codegen/../light-java-example/ms_chain/api_a/generated/.project
[main] INFO io.swagger.codegen.AbstractGenerator - writing file /Users/stevehu/networknt/swagger-codegen/../light-java-example/ms_chain/api_a/generated/src/main/resources/config/swagger.json
[main] INFO io.swagger.codegen.AbstractGenerator - writing file /Users/stevehu/networknt/swagger-codegen/../light-java-example/ms_chain/api_a/generated/src/main/java/io/swagger/PathHandlerProvider.java
[main] INFO io.swagger.codegen.AbstractGenerator - writing file /Users/stevehu/networknt/swagger-codegen/../light-java-example/ms_chain/api_a/generated/src/test/java/io/swagger/handler/TestServer.java
[main] INFO io.swagger.codegen.AbstractGenerator - writing file /Users/stevehu/networknt/swagger-codegen/../light-java-example/ms_chain/api_a/generated/src/main/resources/META-INF/services/com.networknt.server.HandlerProvider
[main] INFO io.swagger.codegen.AbstractGenerator - writing file /Users/stevehu/networknt/swagger-codegen/../light-java-example/ms_chain/api_a/generated/src/main/resources/META-INF/services/com.networknt.handler.MiddlewareHandler
[main] INFO io.swagger.codegen.AbstractGenerator - writing file /Users/stevehu/networknt/swagger-codegen/../light-java-example/ms_chain/api_a/generated/src/main/resources/META-INF/services/com.networknt.server.StartupHookProvider
[main] INFO io.swagger.codegen.AbstractGenerator - writing file /Users/stevehu/networknt/swagger-codegen/../light-java-example/ms_chain/api_a/generated/src/main/resources/META-INF/services/com.networknt.server.ShutdownHookProvider
[main] INFO io.swagger.codegen.AbstractGenerator - writing file /Users/stevehu/networknt/swagger-codegen/../light-java-example/ms_chain/api_a/generated/src/main/resources/config/server.yml
[main] INFO io.swagger.codegen.AbstractGenerator - writing file /Users/stevehu/networknt/swagger-codegen/../light-java-example/ms_chain/api_a/generated/src/main/resources/config/security.yml
[main] INFO io.swagger.codegen.AbstractGenerator - writing file /Users/stevehu/networknt/swagger-codegen/../light-java-example/ms_chain/api_a/generated/src/main/resources/config/secret.yml
[main] INFO io.swagger.codegen.DefaultGenerator - writing file /Users/stevehu/networknt/swagger-codegen/../light-java-example/ms_chain/api_a/generated/src/main/resources/config/oauth/primary.crt
[main] INFO io.swagger.codegen.DefaultGenerator - writing file /Users/stevehu/networknt/swagger-codegen/../light-java-example/ms_chain/api_a/generated/src/main/resources/config/oauth/secondary.crt
[main] INFO io.swagger.codegen.DefaultGenerator - writing file /Users/stevehu/networknt/swagger-codegen/../light-java-example/ms_chain/api_a/generated/src/main/resources/config/tls/server.keystore
[main] INFO io.swagger.codegen.DefaultGenerator - writing file /Users/stevehu/networknt/swagger-codegen/../light-java-example/ms_chain/api_a/generated/src/main/resources/config/tls/server.truststore
[main] INFO io.swagger.codegen.DefaultGenerator - writing file /Users/stevehu/networknt/swagger-codegen/../light-java-example/ms_chain/api_a/generated/src/main/resources/logback.xml
[main] INFO io.swagger.codegen.DefaultGenerator - writing file /Users/stevehu/networknt/swagger-codegen/../light-java-example/ms_chain/api_a/generated/src/test/resources/logback-test.xml
[main] INFO io.swagger.codegen.AbstractGenerator - writing file /Users/stevehu/networknt/swagger-codegen/../light-java-example/ms_chain/api_a/generated/.swagger-codegen-ignore
[main] INFO io.swagger.codegen.AbstractGenerator - writing file /Users/stevehu/networknt/swagger-codegen/../light-java-example/ms_chain/api_a/generated/LICENSE

&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;build-and-run-the-mock-api&#34;&gt;Build and run the mock API&lt;/h4&gt;

&lt;p&gt;And now you have a new project created in light-java-example. Let&amp;rsquo;s build
it and run the test cases. If everything is OK, start the server.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd ..
cd light-java-example/ms_chain/api_a/generated
mvn clean install
mvn exec:exec
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;rsquo;s test the API A by issuing the following command&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;curl localhost:8080/v1/data
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;By default the generated response example will be returned.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[ &amp;quot;aeiou&amp;quot; ]
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;generate-other-apis&#34;&gt;Generate other APIs&lt;/h4&gt;

&lt;p&gt;Let&amp;rsquo;s kill the API A by Ctrl+C and move to the swagger-codegen folder again. Follow
the above steps to generate other APIs. Make sure you are in swagger_codegen
directory.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;java -jar modules/swagger-codegen-cli/target/swagger-codegen-cli.jar generate -i ../swagger/api_b/swagger.yaml -l light-java -o ../light-java-example/ms_chain/api_b/generated
java -jar modules/swagger-codegen-cli/target/swagger-codegen-cli.jar generate -i ../swagger/api_c/swagger.yaml -l light-java -o ../light-java-example/ms_chain/api_c/generated
java -jar modules/swagger-codegen-cli/target/swagger-codegen-cli.jar generate -i ../swagger/api_d/swagger.yaml -l light-java -o ../light-java-example/ms_chain/api_d/generated

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now you have four APIs generated from four OpenAPI specifications. Let&amp;rsquo;s check
them in. Note that you might not have write access to this repo, so you can ignore
this step.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd ../light-java-example
git add .
git commit -m &amp;quot;checkin 4 apis&amp;quot;
git push origin master
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;apitoapi&#34;&gt;ApiToApi&lt;/h2&gt;

&lt;p&gt;Now these APIs are working if you start them and they will output the mock responses
generated based on the API specifications. But you have to start them one by one as they
are all binding to the same port at localhost. Let&amp;rsquo;s take a look at the API handler itself
and update it based on our business logic and update the configuration to start them at
the same time. Once they are up and running, you can call API A and subsequently all other
APIs will be called in a chain.&lt;/p&gt;

&lt;h4 id=&#34;prepare-environment&#34;&gt;Prepare Environment&lt;/h4&gt;

&lt;p&gt;Before starting this step, let&amp;rsquo;s create a folder called apitoapi in each sub folder under
ms_chain and copy everything from generated folder to the apitoapi. We are going to update
apitoapi folder to have business logic to call another api and change the configuration
to listen to different port. You can compare between generated and apitoapi to see what has
been changed later on.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd ~/networknt/light-java-example/ms_chain/api_a
cp -r generated apitoapi
cd ~/networknt/light-java-example/ms_chain/api_b
cp -r generated apitoapi
cd ~/networknt/light-java-example/ms_chain/api_b
cp -r generated apitoapi
cd ~/networknt/light-java-example/ms_chain/api_d
cp -r generated apitoapi

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we have apitoapi folder copied from generated and all updates in this step will be
in apitoapi folder.&lt;/p&gt;

&lt;h4 id=&#34;api-d&#34;&gt;API D&lt;/h4&gt;

&lt;p&gt;Let&amp;rsquo;s take a look at the PathHandlerProvider.java in
ms_chain/api_d/apitoapi/src/main/java/io/swagger/&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package io.swagger;

import com.networknt.config.Config;
import com.networknt.server.HandlerProvider;
import io.undertow.Handlers;
import io.undertow.server.HttpHandler;
import io.undertow.server.HttpServerExchange;
import io.undertow.util.Methods;
import com.networknt.info.ServerInfoGetHandler;
import io.swagger.handler.*;

public class PathHandlerProvider implements HandlerProvider {
    @Override
    public HttpHandler getHandler() {
        return Handlers.routing()
            .add(Methods.GET, &amp;quot;/v1/data&amp;quot;, new DataGetHandler())
            .add(Methods.GET, &amp;quot;/v1/server/info&amp;quot;, new ServerInfoGetHandler())
        ;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is the only class that routes each endpoint defined in specification to a handler
instance. Because we only have one endpoint /v1/data@get there is only one route added
to the handler chain. And there is a handler generated in the handler subfolder to
handle request that has the url matched to this endpoint. The /server/info is injected
to output the server runtime information on all the components and configurations. It
will be included in every API/service.&lt;/p&gt;

&lt;p&gt;The generated handler is named &amp;ldquo;DataGetHandler&amp;rdquo; and it returns example response generated
based on the swagger specification. Here is the generated handler code.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package io.swagger.handler;

import io.undertow.server.HttpHandler;
import io.undertow.server.HttpServerExchange;
import io.undertow.util.HttpString;
import java.util.HashMap;
import java.util.Map;
import org.apache.commons.lang3.StringEscapeUtils;

public class DataGetHandler implements HttpHandler {
    @Override
    public void handleRequest(HttpServerExchange exchange) throws Exception {
        Map&amp;lt;String, Object&amp;gt; examples = new HashMap&amp;lt;&amp;gt;();
        examples.put(&amp;quot;application/json&amp;quot;, StringEscapeUtils.unescapeHtml4(&amp;quot;[ &amp;amp;quot;aeiou&amp;amp;quot; ]&amp;quot;));
        if(examples.size() &amp;gt; 0) {
            exchange.getResponseHeaders().add(new HttpString(&amp;quot;Content-Type&amp;quot;), &amp;quot;application/json&amp;quot;);
            exchange.getResponseSender().send((String)examples.get(&amp;quot;application/json&amp;quot;));
        } else {
            exchange.endExchange();
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;rsquo;s update it to an array of strings that indicates the response comes from API D.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package io.swagger.handler;

import com.networknt.config.Config;
import io.undertow.server.HttpHandler;
import io.undertow.server.HttpServerExchange;
import io.undertow.util.HttpString;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import org.apache.commons.lang3.StringEscapeUtils;

public class DataGetHandler implements HttpHandler {

    public void handleRequest(HttpServerExchange exchange) throws Exception {
        List&amp;lt;String&amp;gt; messages = new ArrayList&amp;lt;String&amp;gt;();
        messages.add(&amp;quot;API D: Message 1&amp;quot;);
        messages.add(&amp;quot;API D: Message 2&amp;quot;);
        exchange.getResponseSender().send(Config.getInstance().getMapper().writeValueAsString(messages));
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In order to start all servers at the same time, let&amp;rsquo;s update server.yml to user
port 7004 instead of default 8080 for http and 7444 for https.&lt;/p&gt;

&lt;p&gt;The server.yml is located at
~/networknt/light-java-example/ms_chain/api_d/apitoapi/src/main/resources/config&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# Server configuration
---
# This is the default binding address if the service is dockerized.
ip: 0.0.0.0

# Http port if enableHttp is true.
httpPort: 7004

# Enable HTTP should be false on official environment.
enableHttp: true

# Https port if enableHttps is true.
httpsPort: 7444

# Enable HTTPS should be true on official environment.
enableHttps: true

# Keystore file name in config folder. KeystorePass is in secret.yml to access it.
keystoreName: tls/server.keystore

# Flag that indicate if two way TLS is enabled. Not recommended in docker container.
enableTwoWayTls: false

# Truststore file name in config folder. TruststorePass is in secret.yml to access it.
truststoreName: tls/server.truststore

# Unique service identifier. Used in service registration and discovery etc.
serviceId: io.swagger.swagger-light-java-1.0.0

# Flag to enable service registration. Only be true if running as standalone Java jar.
enableRegistry: false

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now, let&amp;rsquo;s build it and start the server.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd ~/networknt/light-java-example/ms_chain/api_d/apitoapi
mvn clean package exec:exec
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Test it with curl.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;curl localhost:8080/v1/data
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And the result is&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[&amp;quot;API D: Message 1&amp;quot;,&amp;quot;API D: Message 2&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Test with HTTPS port and you should have the same result.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;curl -k https://localhost:7444/v1/data
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that we have -k option to in the https command line as we are using self-signed
certificate and we don&amp;rsquo;t want to verify the domain.&lt;/p&gt;

&lt;h4 id=&#34;api-c&#34;&gt;API C&lt;/h4&gt;

&lt;p&gt;Let&amp;rsquo;s leave API D running and update API C DataGetHandler in
~/networknt/light-java-example/ms_chain/api_c/apitoapi&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package io.swagger.handler;

import com.fasterxml.jackson.core.type.TypeReference;
import com.networknt.client.Client;
import com.networknt.config.Config;
import com.networknt.exception.ClientException;
import io.undertow.server.HttpHandler;
import io.undertow.server.HttpServerExchange;

import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import org.apache.http.client.methods.CloseableHttpResponse;
import org.apache.http.client.methods.HttpGet;
import org.apache.http.impl.client.CloseableHttpClient;

public class DataGetHandler implements HttpHandler {

    static String CONFIG_NAME = &amp;quot;api_c&amp;quot;;
    static String apidUrl = (String)Config.getInstance().getJsonMapConfig(CONFIG_NAME).get(&amp;quot;api_d_endpoint&amp;quot;);

    public void handleRequest(HttpServerExchange exchange) throws Exception {
        List&amp;lt;String&amp;gt; list = new ArrayList&amp;lt;String&amp;gt;();
        try {
            CloseableHttpClient client = Client.getInstance().getSyncClient();
            HttpGet httpGet = new HttpGet(apidUrl);
            CloseableHttpResponse response = client.execute(httpGet);
            int responseCode = response.getStatusLine().getStatusCode();
            if(responseCode != 200){
                throw new Exception(&amp;quot;Failed to call API D: &amp;quot; + responseCode);
            }
            List&amp;lt;String&amp;gt; apidList = (List&amp;lt;String&amp;gt;) Config.getInstance().getMapper().readValue(response.getEntity().getContent(),
                    new TypeReference&amp;lt;List&amp;lt;String&amp;gt;&amp;gt;(){});
            list.addAll(apidList);
        } catch (ClientException e) {
            throw new Exception(&amp;quot;Client Exception: &amp;quot;, e);
        } catch (IOException e) {
            throw new Exception(&amp;quot;IOException:&amp;quot;, e);
        }
        list.add(&amp;quot;API C: Message 1&amp;quot;);
        list.add(&amp;quot;API C: Message 2&amp;quot;);
        exchange.getResponseSender().send(Config.getInstance().getMapper().writeValueAsString(list));
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now let&amp;rsquo;s change the server.yml to have http port 7003 and https port 7443&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# Server configuration
---
# This is the default binding address if the service is dockerized.
ip: 0.0.0.0

# Http port if enableHttp is true.
httpPort: 7003

# Enable HTTP should be false on official environment.
enableHttp: true

# Https port if enableHttps is true.
httpsPort: 7443

# Enable HTTPS should be true on official environment.
enableHttps: true

# Keystore file name in config folder. KeystorePass is in secret.yml to access it.
keystoreName: tls/server.keystore

# Flag that indicate if two way TLS is enabled. Not recommended in docker container.
enableTwoWayTls: false

# Truststore file name in config folder. TruststorePass is in secret.yml to access it.
truststoreName: tls/server.truststore

# Unique service identifier. Used in service registration and discovery etc.
serviceId: io.swagger.swagger-light-java-1.0.0

# Flag to enable service registration. Only be true if running as standalone Java jar.
enableRegistry: false

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;API C needs to have the url of API D in order to call it. Let&amp;rsquo;s put it in a config file for
now and move to service discovery later.&lt;/p&gt;

&lt;p&gt;Create api_c.yml in src/main/resources/config folder.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;api_d_endpoint: &amp;quot;http://localhost:7004/v1/data&amp;quot;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Start API C server and test the endpoint /v1/data&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd ~/networknt/light-java-example/ms_chain/api_c/apitoapi
mvn clean install exec:exec
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;From another terminal window run:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;curl localhost:7003/v1/data
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And the result is&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[&amp;quot;API D: Message 1&amp;quot;,&amp;quot;API D: Message 2&amp;quot;,&amp;quot;API C: Message 1&amp;quot;,&amp;quot;API C: Message 2&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;api-b&#34;&gt;API B&lt;/h4&gt;

&lt;p&gt;Let&amp;rsquo;s keep API C and API D running. The next step is to complete API B. API B
will call API C to fulfill its request.&lt;/p&gt;

&lt;p&gt;Now let&amp;rsquo;s update the generated DataGetHandler.java to this.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package io.swagger.handler;

import com.fasterxml.jackson.core.type.TypeReference;
import com.networknt.client.Client;
import com.networknt.config.Config;
import com.networknt.exception.ClientException;
import io.undertow.server.HttpHandler;
import io.undertow.server.HttpServerExchange;

import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import org.apache.http.client.methods.CloseableHttpResponse;
import org.apache.http.client.methods.HttpGet;
import org.apache.http.impl.client.CloseableHttpClient;

public class DataGetHandler implements HttpHandler {
    static String CONFIG_NAME = &amp;quot;api_b&amp;quot;;
    static String apidUrl = (String)Config.getInstance().getJsonMapConfig(CONFIG_NAME).get(&amp;quot;api_c_endpoint&amp;quot;);

    public void handleRequest(HttpServerExchange exchange) throws Exception {
        List&amp;lt;String&amp;gt; list = new ArrayList&amp;lt;String&amp;gt;();
        try {
            CloseableHttpClient client = Client.getInstance().getSyncClient();
            HttpGet httpGet = new HttpGet(apidUrl);
            CloseableHttpResponse response = client.execute(httpGet);
            int responseCode = response.getStatusLine().getStatusCode();
            if(responseCode != 200){
                throw new Exception(&amp;quot;Failed to call API C: &amp;quot; + responseCode);
            }
            List&amp;lt;String&amp;gt; apicList = (List&amp;lt;String&amp;gt;) Config.getInstance().getMapper().readValue(response.getEntity().getContent(),
                    new TypeReference&amp;lt;List&amp;lt;String&amp;gt;&amp;gt;(){});
            list.addAll(apicList);
        } catch (ClientException e) {
            throw new Exception(&amp;quot;Client Exception: &amp;quot;, e);
        } catch (IOException e) {
            throw new Exception(&amp;quot;IOException:&amp;quot;, e);
        }
        // now add API B specific messages
        list.add(&amp;quot;API B: Message 1&amp;quot;);
        list.add(&amp;quot;API B: Message 2&amp;quot;);
        exchange.getResponseSender().send(Config.getInstance().getMapper().writeValueAsString(list));
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now let&amp;rsquo;s change the server.yml to have http port 7002 and https port 7442&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# Server configuration
---
# This is the default binding address if the service is dockerized.
ip: 0.0.0.0

# Http port if enableHttp is true.
httpPort: 7002

# Enable HTTP should be false on official environment.
enableHttp: true

# Https port if enableHttps is true.
httpsPort: 7442

# Enable HTTPS should be true on official environment.
enableHttps: true

# Keystore file name in config folder. KeystorePass is in secret.yml to access it.
keystoreName: tls/server.keystore

# Flag that indicate if two way TLS is enabled. Not recommended in docker container.
enableTwoWayTls: false

# Truststore file name in config folder. TruststorePass is in secret.yml to access it.
truststoreName: tls/server.truststore

# Unique service identifier. Used in service registration and discovery etc.
serviceId: io.swagger.swagger-light-java-1.0.0

# Flag to enable service registration. Only be true if running as standalone Java jar.
enableRegistry: false

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;API B needs to have the url of API C in order to call it. Let&amp;rsquo;s put it in a config file for
now and move to service discovery later.&lt;/p&gt;

&lt;p&gt;Create api_b.yml in src/main/resources/config folder.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;api_c_endpoint: &amp;quot;http://localhost:7003/v1/data&amp;quot;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Start API B server and test the endpoint /v1/data&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd ~/networknt/light-java-example/ms_chain/api_b/apitoapi
mvn clean install exec:exec
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;From another terminal window run:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;curl localhost:7002/v1/data
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And the result is&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[&amp;quot;API D: Message 1&amp;quot;,&amp;quot;API D: Message 2&amp;quot;,&amp;quot;API C: Message 1&amp;quot;,&amp;quot;API C: Message 2&amp;quot;,&amp;quot;API B: Message 1&amp;quot;,&amp;quot;API B: Message 2&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;api-a&#34;&gt;API A&lt;/h4&gt;

&lt;p&gt;API A will call API B to fulfill its request. Now let&amp;rsquo;s update the
generated DataGetHandler.java code to&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package io.swagger.handler;

import com.fasterxml.jackson.core.type.TypeReference;
import com.networknt.client.Client;
import com.networknt.config.Config;
import com.networknt.exception.ClientException;
import io.undertow.server.HttpHandler;
import io.undertow.server.HttpServerExchange;

import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import org.apache.http.client.methods.CloseableHttpResponse;
import org.apache.http.client.methods.HttpGet;
import org.apache.http.impl.client.CloseableHttpClient;

public class DataGetHandler implements HttpHandler {
    static String CONFIG_NAME = &amp;quot;api_a&amp;quot;;
    static String apidUrl = (String)Config.getInstance().getJsonMapConfig(CONFIG_NAME).get(&amp;quot;api_b_endpoint&amp;quot;);

    public void handleRequest(HttpServerExchange exchange) throws Exception {
        List&amp;lt;String&amp;gt; list = new ArrayList&amp;lt;String&amp;gt;();
        try {
            CloseableHttpClient client = Client.getInstance().getSyncClient();
            HttpGet httpGet = new HttpGet(apidUrl);
            CloseableHttpResponse response = client.execute(httpGet);
            int responseCode = response.getStatusLine().getStatusCode();
            if(responseCode != 200){
                throw new Exception(&amp;quot;Failed to call API B: &amp;quot; + responseCode);
            }
            List&amp;lt;String&amp;gt; apicList = (List&amp;lt;String&amp;gt;) Config.getInstance().getMapper().readValue(response.getEntity().getContent(),
                    new TypeReference&amp;lt;List&amp;lt;String&amp;gt;&amp;gt;(){});
            list.addAll(apicList);
        } catch (ClientException e) {
            throw new Exception(&amp;quot;Client Exception: &amp;quot;, e);
        } catch (IOException e) {
            throw new Exception(&amp;quot;IOException:&amp;quot;, e);
        }
        // now add API B specific messages
        list.add(&amp;quot;API A: Message 1&amp;quot;);
        list.add(&amp;quot;API A: Message 2&amp;quot;);
        exchange.getResponseSender().send(Config.getInstance().getMapper().writeValueAsString(list));
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now let&amp;rsquo;s change the server.yml to have http port 7001 and https port 7441&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# Server configuration
---
# This is the default binding address if the service is dockerized.
ip: 0.0.0.0

# Http port if enableHttp is true.
httpPort: 7001

# Enable HTTP should be false on official environment.
enableHttp: true

# Https port if enableHttps is true.
httpsPort: 7441

# Enable HTTPS should be true on official environment.
enableHttps: true

# Keystore file name in config folder. KeystorePass is in secret.yml to access it.
keystoreName: tls/server.keystore

# Flag that indicate if two way TLS is enabled. Not recommended in docker container.
enableTwoWayTls: false

# Truststore file name in config folder. TruststorePass is in secret.yml to access it.
truststoreName: tls/server.truststore

# Unique service identifier. Used in service registration and discovery etc.
serviceId: io.swagger.swagger-light-java-1.0.0

# Flag to enable service registration. Only be true if running as standalone Java jar.
enableRegistry: false

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;API A needs to have the url of API in order to call it. Let&amp;rsquo;s put it in a config file for
now and move to service discovery later.&lt;/p&gt;

&lt;p&gt;Create api_a.yml in src/main/resources/config folder.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;api_b_endpoint: &amp;quot;http://localhost:7002/v1/data&amp;quot;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Start API A server and test the endpoint /v1/data&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd ~/networknt/light-java-example/ms_chain/api_a/apitoapi
mvn clean install exec:exec
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;From another terminal window run:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;curl localhost:7002/v1/data
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And the result is&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[&amp;quot;API D: Message 1&amp;quot;,&amp;quot;API D: Message 2&amp;quot;,&amp;quot;API C: Message 1&amp;quot;,&amp;quot;API C: Message 2&amp;quot;,&amp;quot;API B: Message 1&amp;quot;,&amp;quot;API B: Message 2&amp;quot;,&amp;quot;API A: Message 1&amp;quot;,&amp;quot;API A: Message 2&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;At this moment, we have all four APIs completed and A is calling B, B is calling C and
C is calling D.&lt;/p&gt;

&lt;h2 id=&#34;performance-without-security&#34;&gt;Performance without security&lt;/h2&gt;

&lt;p&gt;Now let&amp;rsquo;s see if these servers are performing with
&lt;a href=&#34;https://github.com/wg/wrk&#34;&gt;wrk&lt;/a&gt;. To learn how to use it, please see my
article in tools &lt;a href=&#34;https://networknt.github.io/light-java/tools/wrk-perf/&#34;&gt;here&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Assume you have wrk installed, run the following command.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;wrk -t4 -c128 -d30s http://localhost:7001 -s pipeline.lua --latency -- /v1/data 1024

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And here is what I got on my laptop&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;wrk -t4 -c128 -d30s http://localhost:7001 -s pipeline.lua --latency -- /v1/data 1024
Running 30s test @ http://localhost:7001
  4 threads and 128 connections
  Thread Stats   Avg      Stdev     Max   +/- Stdev
    Latency     0.00us    0.00us   0.00us     nan%
    Req/Sec     2.54k     1.32k    9.52k    71.22%
  Latency Distribution
     50%    0.00us
     75%    0.00us
     90%    0.00us
     99%    0.00us
  286072 requests in 30.09s, 65.75MB read
  Socket errors: connect 0, read 0, write 0, timeout 254
Requests/sec:   9505.92
Transfer/sec:      2.18MB
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Before starting the next step, please kill all four instances by Ctrl+C.&lt;/p&gt;

&lt;h2 id=&#34;docker-compose&#34;&gt;Docker Compose&lt;/h2&gt;

&lt;p&gt;So far, we have four servers running and they can talk to each other as standalone
services. In this step, we are going to dockerize all of them and start them with a
docker-compose up command.&lt;/p&gt;

&lt;p&gt;Before doing that, let&amp;rsquo;s create two folders under ms_chain for different version of
compose files and externalized config files.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd ~/networknt/light-java-example/ms_chain
mkdir compose
mkdir config
cd compose
mkdir apionly
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now in the config folder, we need to create sub folders for each api and inside, we need
to create apionly folder.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd ~/networknt/light-java-example/ms_chain/config
mkdir api_a
mkdir api_b
mkdir api_c
mkdir api_d

cd api_a
mkdir apionly
cd ../api_b
mkdir apionly
cd ../api_c
mkdir apionly
cd ../api_d
mkdir apionly

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;rsquo;s create a ms_chain/compose/apionly/docker-compose-app.yml.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#
# docker-compose-app.yml
#

version: &#39;2&#39;

#
# Services
#
services:


    #
    # Microservice: API A
    #
    apia:
        build: ~/networknt/light-java-example/ms_chain/api_a/apitoapi/
        ports:
            - &amp;quot;7001:7001&amp;quot;
        networks:
            - localnet
        volumes:
            - ~/networknt/light-java-example/ms_chain/config/api_a/apionly:/config

    #
    # Microservice: API B
    #
    apib:
        build: ~/networknt/light-java-example/ms_chain/api_b/apitoapi/
        ports:
            - &amp;quot;7002:7002&amp;quot;
        networks:
            - localnet
        volumes:
            - ~/networknt/light-java-example/ms_chain/config/api_b/apionly:/config

    #
    # Microservice: API C
    #
    apic:
        build: ~/networknt/light-java-example/ms_chain/api_c/apitoapi/
        ports:
            - &amp;quot;7003:7003&amp;quot;
        networks:
            - localnet
        volumes:
            - ~/networknt/light-java-example/ms_chain/config/api_c/apionly:/config

    #
    # Microservice: API D
    #
    apid:
        build: ~/networknt/light-java-example/ms_chain/api_d/apitoapi/
        ports:
            - &amp;quot;7004:7004&amp;quot;
        networks:
            - localnet
        volumes:
            - ~/networknt/light-java-example/ms_chain/config/api_d/apionly:/config

#
# Networks
#
networks:
    localnet:
        external: true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;From above docker compose file you can see we have a volume for each api with externalized
configuration folder under ms_chain/config/api_x/apionly. Since we are using docker compose
we cannot use localhost:port to call services and we have to use service name in
docker-compose-app.yml for the hostname. To resolve the issue without rebuilding the services
we are going to externalize api_a.yml, api_b.yml and api_c.yml to their externalized config
folder.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s create api_a.yml in ms_chain/config/api_a/apionly folder&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;api_b_endpoint: &amp;quot;http://apib:7002/v1/data&amp;quot;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Please note that apib is the name of the service in docker-compose-app.yml&lt;/p&gt;

&lt;p&gt;Create api_b.yml in ms_chain/config/api_b/apionly folder&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;api_c_endpoint: &amp;quot;http://apic:7003/v1/data&amp;quot;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Create api_c.yml in ms_chain/config/api_c/apionly folder&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;api_d_endpoint: &amp;quot;http://apid:7004/v1/data&amp;quot;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now let&amp;rsquo;s start the docker compose.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd ~/networknt/light-java-example/ms_chain/compose/apionly
docker-compose -f docker-compose-app.yml up
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;rsquo;s test if the servers are working.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;curl localhost:7001/v1/data
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And we will have the result.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[&amp;quot;API D: Message 1&amp;quot;,&amp;quot;API D: Message 2&amp;quot;,&amp;quot;API C: Message 1&amp;quot;,&amp;quot;API C: Message 2&amp;quot;,&amp;quot;API B: Message 1&amp;quot;,&amp;quot;API B: Message 2&amp;quot;,&amp;quot;API A: Message 1&amp;quot;,&amp;quot;API A: Message 2&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;rsquo;s run a load test now.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;wrk -t4 -c128 -d30s http://localhost:7001 -s pipeline.lua --latency -- /v1/data 1024
Running 30s test @ http://localhost:7001
  4 threads and 128 connections
  Thread Stats   Avg      Stdev     Max   +/- Stdev
    Latency     0.00us    0.00us   0.00us     nan%
    Req/Sec   592.29    423.59     2.72k    70.98%
  Latency Distribution
     50%    0.00us
     75%    0.00us
     90%    0.00us
     99%    0.00us
  39712 requests in 30.10s, 9.13MB read
  Socket errors: connect 0, read 4, write 5, timeout 0
Requests/sec:   1319.39
Transfer/sec:    310.52KB
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;enable-oauth2-security&#34;&gt;Enable OAuth2 Security&lt;/h2&gt;

&lt;p&gt;So far, we&amp;rsquo;ve started four servers and tested them successfully; however,
these servers are not protected by OAuth2 JWT tokens as it is turned off
by default in the generated code.&lt;/p&gt;

&lt;p&gt;Before we turn on the security, we need to have &lt;a href=&#34;https://github.com/networknt/light-oauth2&#34;&gt;light-oauth2&lt;/a&gt;
server up and running so that these servers can get JWT token in real time.&lt;/p&gt;

&lt;p&gt;When we enable security, the source code needs to be updated in order to
leverage client module to get JWT token automatically. Let&amp;rsquo;s prepare the
environment.&lt;/p&gt;

&lt;h4 id=&#34;update-apis&#34;&gt;Update  APIs&lt;/h4&gt;

&lt;p&gt;Since we are going to change the code, let&amp;rsquo;s copy each service into a new folder
called security from apitoapi.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd ~/networknt/light-java-example/ms_chain/api_a
cp -r apitoapi security
cd ~/networknt/light-java-example/ms_chain/api_b
cp -r apitoapi security
cd ~/networknt/light-java-example/ms_chain/api_c
cp -r apitoapi security
cd ~/networknt/light-java-example/ms_chain/api_d
cp -r apitoapi security

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now for api_a, api_b and api_c we need to update DataGetHandler.java to add
a line before client.execute.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;            Client.getInstance().propagateHeaders(httpGet, exchange);

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here is the updated file for api_a&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package io.swagger.handler;

import com.fasterxml.jackson.core.type.TypeReference;
import com.networknt.client.Client;
import com.networknt.config.Config;
import com.networknt.exception.ClientException;
import io.undertow.server.HttpHandler;
import io.undertow.server.HttpServerExchange;

import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import org.apache.http.client.methods.CloseableHttpResponse;
import org.apache.http.client.methods.HttpGet;
import org.apache.http.impl.client.CloseableHttpClient;

public class DataGetHandler implements HttpHandler {
    static String CONFIG_NAME = &amp;quot;api_a&amp;quot;;
    static String apibUrl = (String)Config.getInstance().getJsonMapConfig(CONFIG_NAME).get(&amp;quot;api_b_endpoint&amp;quot;);

    public void handleRequest(HttpServerExchange exchange) throws Exception {
        List&amp;lt;String&amp;gt; list = new ArrayList&amp;lt;String&amp;gt;();
        try {
            CloseableHttpClient client = Client.getInstance().getSyncClient();
            HttpGet httpGet = new HttpGet(apibUrl);
            Client.getInstance().propagateHeaders(httpGet, exchange);
            CloseableHttpResponse response = client.execute(httpGet);
            int responseCode = response.getStatusLine().getStatusCode();
            if(responseCode != 200){
                throw new Exception(&amp;quot;Failed to call API B: &amp;quot; + responseCode);
            }
            List&amp;lt;String&amp;gt; apicList = (List&amp;lt;String&amp;gt;) Config.getInstance().getMapper().readValue(response.getEntity().getContent(),
                    new TypeReference&amp;lt;List&amp;lt;String&amp;gt;&amp;gt;(){});
            list.addAll(apicList);
        } catch (ClientException e) {
            throw new Exception(&amp;quot;Client Exception: &amp;quot;, e);
        } catch (IOException e) {
            throw new Exception(&amp;quot;IOException:&amp;quot;, e);
        }
        // now add API B specific messages
        list.add(&amp;quot;API A: Message 1&amp;quot;);
        list.add(&amp;quot;API A: Message 2&amp;quot;);
        exchange.getResponseSender().send(Config.getInstance().getMapper().writeValueAsString(list));
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Follow api_a, update api_b and api_c.&lt;/p&gt;

&lt;h4 id=&#34;update-config&#34;&gt;Update Config&lt;/h4&gt;

&lt;p&gt;Now let&amp;rsquo;s update security.yml to enable JWT verification and scope verification
for each service. This file is located at src/main/resources/config folder.&lt;/p&gt;

&lt;p&gt;API A&lt;/p&gt;

&lt;p&gt;old file&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# Security configuration in light framework.
---
# Enable JWT verification flag.
enableVerifyJwt: false

# Enable JWT scope verification. Only valid when enableVerifyJwt is true.
enableVerifyScope: true

# User for test only. should be always be false on official environment.
enableMockJwt: false

# JWT signature public certificates. kid and certificate path mappings.
jwt:
  certificate:
    &#39;100&#39;: oauth/primary.crt
    &#39;101&#39;: oauth/secondary.crt
  clockSkewInSeconds: 60

# Enable or disable JWT token logging
logJwtToken: true

# Enable or disable client_id, user_id and scope logging.
logClientUserScope: false

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Update to&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# Security configuration in light framework.
---
# Enable JWT verification flag.
enableVerifyJwt: true

# Enable JWT scope verification. Only valid when enableVerifyJwt is true.
enableVerifyScope: true

# User for test only. should be always be false on official environment.
enableMockJwt: false

# JWT signature public certificates. kid and certificate path mappings.
jwt:
  certificate:
    &#39;100&#39;: oauth/primary.crt
    &#39;101&#39;: oauth/secondary.crt
  clockSkewInSeconds: 60

# Enable or disable JWT token logging
logJwtToken: true

# Enable or disable client_id, user_id and scope logging.
logClientUserScope: false
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Update the security.yml for api_b, api_c and api_d in security folder.&lt;/p&gt;

&lt;h4 id=&#34;start-oauth2-services&#34;&gt;Start OAuth2 Services&lt;/h4&gt;

&lt;p&gt;The easiest way to run light-oauth2 services is through docker-compose. In the preparation
step, we have cloned light-docker repo.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s start the light-oauth2 services from a docker compose.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd ~/networknt/light-docker
docker-compose -f docker-compose-oauth2-mysql.yml up
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now the OAuth2 services are up and running.&lt;/p&gt;

&lt;h4 id=&#34;register-client&#34;&gt;Register Client&lt;/h4&gt;

&lt;p&gt;Before we start integrate with OAuth2 services, we need to register clients for api_a,
api_b, api_c and api_d. This step should be done from light-portal for official environment.
After client registration, we need to remember the client_id and client_secret for each in
order to update client.yml for each service.&lt;/p&gt;

&lt;p&gt;For more details on how to use the command line tool or script to access oauth2 services,
please see this &lt;a href=&#34;https://networknt.github.io/light-oauth2/tutorials/enterprise/&#34;&gt;tutorial&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Register a client that calls api_a.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;curl -H &amp;quot;Content-Type: application/json&amp;quot; -X POST -d &#39;{&amp;quot;clientType&amp;quot;:&amp;quot;public&amp;quot;,&amp;quot;clientProfile&amp;quot;:&amp;quot;mobile&amp;quot;,&amp;quot;clientName&amp;quot;:&amp;quot;Consumer&amp;quot;,&amp;quot;clientDesc&amp;quot;:&amp;quot;A client that calls API A&amp;quot;,&amp;quot;scope&amp;quot;:&amp;quot;api_a.r api_a.w&amp;quot;,&amp;quot;redirectUri&amp;quot;: &amp;quot;http://localhost:8080/authorization&amp;quot;,&amp;quot;ownerId&amp;quot;:&amp;quot;admin&amp;quot;}&#39; http://localhost:6884/oauth2/client

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The return value is&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{&amp;quot;clientId&amp;quot;:&amp;quot;f0439841-fbe7-43a4-843e-ae0c51971a5e&amp;quot;,&amp;quot;clientSecret&amp;quot;:&amp;quot;pu9aCVwmQjK2PET0_vOl9A&amp;quot;,&amp;quot;clientType&amp;quot;:&amp;quot;public&amp;quot;,&amp;quot;clientProfile&amp;quot;:&amp;quot;mobile&amp;quot;,&amp;quot;clientName&amp;quot;:&amp;quot;Consumer&amp;quot;,&amp;quot;clientDesc&amp;quot;:&amp;quot;A client that calls API A&amp;quot;,&amp;quot;ownerId&amp;quot;:&amp;quot;admin&amp;quot;,&amp;quot;scope&amp;quot;:&amp;quot;api_a.r api_a.w&amp;quot;,&amp;quot;redirectUri&amp;quot;:&amp;quot;http://localhost:8080/authorization&amp;quot;,&amp;quot;createDt&amp;quot;:&amp;quot;2017-03-30&amp;quot;,&amp;quot;updateDt&amp;quot;:null}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We will need to use this clientId and clientSecret to generate an access token later on.&lt;/p&gt;

&lt;p&gt;Register a client for api_a to call api_b&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;curl -H &amp;quot;Content-Type: application/json&amp;quot; -X POST -d &#39;{&amp;quot;clientType&amp;quot;:&amp;quot;public&amp;quot;,&amp;quot;clientProfile&amp;quot;:&amp;quot;service&amp;quot;,&amp;quot;clientName&amp;quot;:&amp;quot;api_a&amp;quot;,&amp;quot;clientDesc&amp;quot;:&amp;quot;API A service&amp;quot;,&amp;quot;scope&amp;quot;:&amp;quot;api_b.r api_b.w&amp;quot;,&amp;quot;redirectUri&amp;quot;: &amp;quot;http://localhost:8080/authorization&amp;quot;,&amp;quot;ownerId&amp;quot;:&amp;quot;admin&amp;quot;}&#39; http://localhost:6884/oauth2/client

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And the result is&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{&amp;quot;clientId&amp;quot;:&amp;quot;d5a0fa30-408b-4068-884c-e1f36c9e20e7&amp;quot;,&amp;quot;clientSecret&amp;quot;:&amp;quot;DexYT2-OSHKQtNGsH0YYKQ&amp;quot;,&amp;quot;clientType&amp;quot;:&amp;quot;public&amp;quot;,&amp;quot;clientProfile&amp;quot;:&amp;quot;service&amp;quot;,&amp;quot;clientName&amp;quot;:&amp;quot;api_a&amp;quot;,&amp;quot;clientDesc&amp;quot;:&amp;quot;API A service&amp;quot;,&amp;quot;ownerId&amp;quot;:&amp;quot;admin&amp;quot;,&amp;quot;scope&amp;quot;:&amp;quot;api_b.r api_b.w&amp;quot;,&amp;quot;redirectUri&amp;quot;:&amp;quot;http://localhost:8080/authorization&amp;quot;,&amp;quot;createDt&amp;quot;:&amp;quot;2017-03-30&amp;quot;,&amp;quot;updateDt&amp;quot;:null}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we need to externalize client.yml and update it with this clientId and clientSecret for
api_a. Let&amp;rsquo;s create a config folder for api_a.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd ~/networknt/light-java-example/ms_chain/config/api_a
mkdir security
cp apionly/api_a.yml security
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;rsquo;s create client.yml file in the newly created security folder.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;description: client configuration, all timing is milli-second
sync:
  maxConnectionTotal: 100
  maxConnectionPerRoute: 10
  routes:
    api.google.com: 20
    api.facebook.com: 10
  timeout: 10000
  keepAlive: 15000
async:
  maxConnectionTotal: 100
  maxConnectionPerRoute: 10
  routes:
    api.google.com: 20
    api.facebook.com: 10
  reactor:
    ioThreadCount: 1
    connectTimeout: 10000
    soTimeout: 10000
  timeout: 10000
  keepAlive: 15000
tls:
  verifyHostname: false
  loadTrustStore: false
  trustStore: trust.keystore
  trustPass: password
  loadKeyStore: false
  keyStore: key.jks
  keyPass: password
oauth:
  tokenRenewBeforeExpired: 600000
  expiredRefreshRetryDelay: 5000
  earlyRefreshRetryDelay: 30000
  server_url: http://oauth2-token:6882
  authorization_code:
    uri: &amp;quot;/oauth2/token&amp;quot;
    client_id: d5a0fa30-408b-4068-884c-e1f36c9e20e7
    client_secret: DexYT2-OSHKQtNGsH0YYKQ
    redirect_uri: https://localhost:8080/authorization_code
    scope:
    - api_b.r
    - api_b.w
  client_credentials:
    uri: &amp;quot;/oauth2/token&amp;quot;
    client_id: d5a0fa30-408b-4068-884c-e1f36c9e20e7
    client_secret: DexYT2-OSHKQtNGsH0YYKQ
    scope:
    - api_b.r
    - api_b.w

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As you can see the server_url is pointing to OAuth2 token service at 6882. And
client_id and client_secret are updated according to the client register result.
Also, scope has been updated to api_b.r and api_b.w in roder to access API B.&lt;/p&gt;

&lt;p&gt;Register a client for api_b to call api_c&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;curl -H &amp;quot;Content-Type: application/json&amp;quot; -X POST -d &#39;{&amp;quot;clientType&amp;quot;:&amp;quot;public&amp;quot;,&amp;quot;clientProfile&amp;quot;:&amp;quot;service&amp;quot;,&amp;quot;clientName&amp;quot;:&amp;quot;api_b&amp;quot;,&amp;quot;clientDesc&amp;quot;:&amp;quot;API B service&amp;quot;,&amp;quot;scope&amp;quot;:&amp;quot;api_c.r api_c.w&amp;quot;,&amp;quot;redirectUri&amp;quot;: &amp;quot;http://localhost:8080/authorization&amp;quot;,&amp;quot;ownerId&amp;quot;:&amp;quot;admin&amp;quot;}&#39; http://localhost:6884/oauth2/client

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And the result is&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{&amp;quot;clientId&amp;quot;:&amp;quot;2970c16d-d39b-4ccc-96b0-d6dc4325340f&amp;quot;,&amp;quot;clientSecret&amp;quot;:&amp;quot;H4FpRXo_RLiNatcxce2d8g&amp;quot;,&amp;quot;clientType&amp;quot;:&amp;quot;public&amp;quot;,&amp;quot;clientProfile&amp;quot;:&amp;quot;service&amp;quot;,&amp;quot;clientName&amp;quot;:&amp;quot;api_b&amp;quot;,&amp;quot;clientDesc&amp;quot;:&amp;quot;API B service&amp;quot;,&amp;quot;ownerId&amp;quot;:&amp;quot;admin&amp;quot;,&amp;quot;scope&amp;quot;:&amp;quot;api_c.r api_c.w&amp;quot;,&amp;quot;redirectUri&amp;quot;:&amp;quot;http://localhost:8080/authorization&amp;quot;,&amp;quot;createDt&amp;quot;:&amp;quot;2017-03-30&amp;quot;,&amp;quot;updateDt&amp;quot;:null}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we need to externalize client.yml and update it with this clientId and clientSecret for
api_b. Let&amp;rsquo;s create a config folder for api_b.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd ~/networknt/light-java-example/ms_chain/config/api_b
mkdir security
cp apionly/api_b.yml security
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;rsquo;s create client.yml file in the newly created security folder.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;description: client configuration, all timing is milli-second
sync:
  maxConnectionTotal: 100
  maxConnectionPerRoute: 10
  routes:
    api.google.com: 20
    api.facebook.com: 10
  timeout: 10000
  keepAlive: 15000
async:
  maxConnectionTotal: 100
  maxConnectionPerRoute: 10
  routes:
    api.google.com: 20
    api.facebook.com: 10
  reactor:
    ioThreadCount: 1
    connectTimeout: 10000
    soTimeout: 10000
  timeout: 10000
  keepAlive: 15000
tls:
  verifyHostname: false
  loadTrustStore: false
  trustStore: trust.keystore
  trustPass: password
  loadKeyStore: false
  keyStore: key.jks
  keyPass: password
oauth:
  tokenRenewBeforeExpired: 600000
  expiredRefreshRetryDelay: 5000
  earlyRefreshRetryDelay: 30000
  server_url: http://oauth2-token:6882
  authorization_code:
    uri: &amp;quot;/oauth2/token&amp;quot;
    client_id: 2970c16d-d39b-4ccc-96b0-d6dc4325340f
    client_secret: H4FpRXo_RLiNatcxce2d8g
    redirect_uri: https://localhost:8080/authorization_code
    scope:
    - api_c.r
    - api_c.w
  client_credentials:
    uri: &amp;quot;/oauth2/token&amp;quot;
    client_id: 2970c16d-d39b-4ccc-96b0-d6dc4325340f
    client_secret: H4FpRXo_RLiNatcxce2d8g
    scope:
    - api_c.r
    - api_c.w

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Register a client for api_c to call api_d&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;curl -H &amp;quot;Content-Type: application/json&amp;quot; -X POST -d &#39;{&amp;quot;clientType&amp;quot;:&amp;quot;public&amp;quot;,&amp;quot;clientProfile&amp;quot;:&amp;quot;service&amp;quot;,&amp;quot;clientName&amp;quot;:&amp;quot;api_c&amp;quot;,&amp;quot;clientDesc&amp;quot;:&amp;quot;API C service&amp;quot;,&amp;quot;scope&amp;quot;:&amp;quot;api_d.r api_d.w&amp;quot;,&amp;quot;redirectUri&amp;quot;: &amp;quot;http://localhost:8080/authorization&amp;quot;,&amp;quot;ownerId&amp;quot;:&amp;quot;admin&amp;quot;}&#39; http://localhost:6884/oauth2/client

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And the result is&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{&amp;quot;clientId&amp;quot;:&amp;quot;50c92172-d223-4902-9779-df9ef501724f&amp;quot;,&amp;quot;clientSecret&amp;quot;:&amp;quot;ZOz5tiF8TqmichIkVO9EPg&amp;quot;,&amp;quot;clientType&amp;quot;:&amp;quot;public&amp;quot;,&amp;quot;clientProfile&amp;quot;:&amp;quot;service&amp;quot;,&amp;quot;clientName&amp;quot;:&amp;quot;api_c&amp;quot;,&amp;quot;clientDesc&amp;quot;:&amp;quot;API C service&amp;quot;,&amp;quot;ownerId&amp;quot;:&amp;quot;admin&amp;quot;,&amp;quot;scope&amp;quot;:&amp;quot;api_d.r api_d.w&amp;quot;,&amp;quot;redirectUri&amp;quot;:&amp;quot;http://localhost:8080/authorization&amp;quot;,&amp;quot;createDt&amp;quot;:&amp;quot;2017-03-30&amp;quot;,&amp;quot;updateDt&amp;quot;:null}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we need to externalize client.yml and update it with this clientId and clientSecret for
api_c. Let&amp;rsquo;s create a config folder for api_c.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd ~/networknt/light-java-example/ms_chain/config/api_c
mkdir security
cp apionly/api_c.yml security
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;rsquo;s create client.yml file in the newly created security folder.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;description: client configuration, all timing is milli-second
sync:
  maxConnectionTotal: 100
  maxConnectionPerRoute: 10
  routes:
    api.google.com: 20
    api.facebook.com: 10
  timeout: 10000
  keepAlive: 15000
async:
  maxConnectionTotal: 100
  maxConnectionPerRoute: 10
  routes:
    api.google.com: 20
    api.facebook.com: 10
  reactor:
    ioThreadCount: 1
    connectTimeout: 10000
    soTimeout: 10000
  timeout: 10000
  keepAlive: 15000
tls:
  verifyHostname: false
  loadTrustStore: false
  trustStore: trust.keystore
  trustPass: password
  loadKeyStore: false
  keyStore: key.jks
  keyPass: password
oauth:
  tokenRenewBeforeExpired: 600000
  expiredRefreshRetryDelay: 5000
  earlyRefreshRetryDelay: 30000
  server_url: http://oauth2-token:6882
  authorization_code:
    uri: &amp;quot;/oauth2/token&amp;quot;
    client_id: 50c92172-d223-4902-9779-df9ef501724f
    client_secret: ZOz5tiF8TqmichIkVO9EPg
    redirect_uri: https://localhost:8080/authorization_code
    scope:
    - api_d.r
    - api_d.w
  client_credentials:
    uri: &amp;quot;/oauth2/token&amp;quot;
    client_id: 50c92172-d223-4902-9779-df9ef501724f
    client_secret: ZOz5tiF8TqmichIkVO9EPg
    scope:
    - api_d.r
    - api_d.w

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;API D is not calling any other API so it is not a client and doesn&amp;rsquo;t need to be registered.&lt;/p&gt;

&lt;p&gt;Now we need to rebuild and restart API A, B, C and D.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd ~/networknt/light-java-example/ms_chain/api_a/security
mvn clean install
cd ~/networknt/light-java-example/ms_chain/api_b/security
mvn clean install
cd ~/networknt/light-java-example/ms_chain/api_c/security
mvn clean install
cd ~/networknt/light-java-example/ms_chain/api_d/security
mvn clean install

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now let&amp;rsquo;s update docker-compose-app.yml in ms_chain/compose/security to point to the
config files from security folder under config.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#
# docker-compose-app.yml
#

version: &#39;2&#39;

#
# Services
#
services:


    #
    # Microservice: API A
    #
    apia:
        build: ~/networknt/light-java-example/ms_chain/api_a/security/
        ports:
            - &amp;quot;7001:7001&amp;quot;
        networks:
            - localnet
        volumes:
            - ~/networknt/light-java-example/ms_chain/config/api_a/security:/config

    #
    # Microservice: API B
    #
    apib:
        build: ~/networknt/light-java-example/ms_chain/api_b/security/
        ports:
            - &amp;quot;7002:7002&amp;quot;
        networks:
            - localnet
        volumes:
            - ~/networknt/light-java-example/ms_chain/config/api_b/security:/config

    #
    # Microservice: API C
    #
    apic:
        build: ~/networknt/light-java-example/ms_chain/api_c/security/
        ports:
            - &amp;quot;7003:7003&amp;quot;
        networks:
            - localnet
        volumes:
            - ~/networknt/light-java-example/ms_chain/config/api_c/security:/config

    #
    # Microservice: API D
    #
    apid:
        build: ~/networknt/light-java-example/ms_chain/api_d/security/
        ports:
            - &amp;quot;7004:7004&amp;quot;
        networks:
            - localnet
        volumes:
            - ~/networknt/light-java-example/ms_chain/config/api_d/security:/config

#
# Networks
#
networks:
    localnet:
        external: true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now let&amp;rsquo;s start these services.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd ~/networknt/light-java-example/ms_chain/compose/security
docker-compose -f docker-compose-app.yml up
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we have both APIs and OAuth2 services running.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s create a token that can access API A. Remember we have created a consumer client?
we need that client id and client secret to create an access token.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;curl -H &amp;quot;Authorization: Basic f0439841-fbe7-43a4-843e-ae0c51971a5e:pu9aCVwmQjK2PET0_vOl9A&amp;quot; -H &amp;quot;Content-Type: application/x-www-form-urlencoded&amp;quot; -X POST -d &amp;quot;grant_type=client_credentials&amp;quot; http://localhost:6882/oauth2/token
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And here is the response&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{&amp;quot;access_token&amp;quot;:&amp;quot;eyJraWQiOiIxMDAiLCJhbGciOiJSUzI1NiJ9.eyJpc3MiOiJ1cm46Y29tOm5ldHdvcmtudDpvYXV0aDI6djEiLCJhdWQiOiJ1cm46Y29tLm5ldHdvcmtudCIsImV4cCI6MTQ5MDgzNzQxNiwianRpIjoiam1vNTFuYTZ1VkUzX3YwaTNxeE5GUSIsImlhdCI6MTQ5MDgzNjgxNiwibmJmIjoxNDkwODM2Njk2LCJ2ZXJzaW9uIjoiMS4wIiwiY2xpZW50X2lkIjoiZjA0Mzk4NDEtZmJlNy00M2E0LTg0M2UtYWUwYzUxOTcxYTVlIiwic2NvcGUiOlsiYXBpX2EuciIsImFwaV9hLnciXX0.mmh-CDll2wH__STv2QgPk9v7p8f5TEBh8XeZyV6q6LUpuQEAhetjVGampz91b1ncn8kmuZQ-WP0q6UAgXq2CavNz3wDa1uvPFmOd0LY7p-Q7vlMdSj3UG6y-4CaP2Keqj7znq0YJUwGNzerQd9HkC6NmPrdUYCXWiIWNENDYqua9xT3d4Sc1lbVWczPsjCovNrXcCo8HTFBO_d5sPi5-0pFcLJ-KszHCzWaSMt7lGfvJX5psVzFf8vO5yurjfriGyBJ4Cdq6aWwMsxoN7PXJB8izFMlDq8UuW6IXNvYRct2sIknlP__UKdqKEP5R7v8dMKlWitcyxqFD-hWRCSbU0w&amp;quot;,&amp;quot;token_type&amp;quot;:&amp;quot;bearer&amp;quot;,&amp;quot;expires_in&amp;quot;:600}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Run the following command to call api_a with the token generated above.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;curl -H &amp;quot;Authorization: Bearer eyJraWQiOiIxMDAiLCJhbGciOiJSUzI1NiJ9.eyJpc3MiOiJ1cm46Y29tOm5ldHdvcmtudDpvYXV0aDI6djEiLCJhdWQiOiJ1cm46Y29tLm5ldHdvcmtudCIsImV4cCI6MTQ5MDgzNzQxNiwianRpIjoiam1vNTFuYTZ1VkUzX3YwaTNxeE5GUSIsImlhdCI6MTQ5MDgzNjgxNiwibmJmIjoxNDkwODM2Njk2LCJ2ZXJzaW9uIjoiMS4wIiwiY2xpZW50X2lkIjoiZjA0Mzk4NDEtZmJlNy00M2E0LTg0M2UtYWUwYzUxOTcxYTVlIiwic2NvcGUiOlsiYXBpX2EuciIsImFwaV9hLnciXX0.mmh-CDll2wH__STv2QgPk9v7p8f5TEBh8XeZyV6q6LUpuQEAhetjVGampz91b1ncn8kmuZQ-WP0q6UAgXq2CavNz3wDa1uvPFmOd0LY7p-Q7vlMdSj3UG6y-4CaP2Keqj7znq0YJUwGNzerQd9HkC6NmPrdUYCXWiIWNENDYqua9xT3d4Sc1lbVWczPsjCovNrXcCo8HTFBO_d5sPi5-0pFcLJ-KszHCzWaSMt7lGfvJX5psVzFf8vO5yurjfriGyBJ4Cdq6aWwMsxoN7PXJB8izFMlDq8UuW6IXNvYRct2sIknlP__UKdqKEP5R7v8dMKlWitcyxqFD-hWRCSbU0w&amp;quot; localhost:7001/v1/data
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And here is the result.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[&amp;quot;API C: Message 1&amp;quot;,&amp;quot;API C: Message 2&amp;quot;,&amp;quot;API D: Message 1&amp;quot;,&amp;quot;API D: Message 2&amp;quot;,&amp;quot;API B: Message 1&amp;quot;,&amp;quot;API B: Message 2&amp;quot;,&amp;quot;API A: Message 1&amp;quot;,&amp;quot;API A: Message 2&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;At this moment, all four APIs are protected by JWT token and API B, C, D are projected by scope additionally.&lt;/p&gt;

&lt;p&gt;We have went though the process to register clients and update client.yml with clientId
and clientSecret for each services except API D. It is a good learning experience but the
process is very slow and error prone. You can follow this on your own to learn interactions
with OAuth2 services but for people who don&amp;rsquo;t want to do it manually, I will put the these
client registraion info into our database script so that it should work once the OAuth2
services are up and running.&lt;/p&gt;

&lt;p&gt;Above we&amp;rsquo;ve recorded all the output for each service registrations and I am going to add
insert statements into light-docker/light-oauth2/mysql/create_mysql.sql&lt;/p&gt;

&lt;p&gt;Our OAuth2 servers support Oracle and Postgres as well and we are going to change these
scripts in their corresponding folders.&lt;/p&gt;

&lt;p&gt;The other benefit to get these clients into the startup scirpt is to avoid redo it every
time the server is restarted.&lt;/p&gt;

&lt;p&gt;Here is the insert statements.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;enable-metrics&#34;&gt;Enable Metrics&lt;/h2&gt;

&lt;p&gt;When you start a service, you might realized that every few minutes, &amp;ldquo;InfluxDbReporter
report is called&amp;rdquo; will be shown up on the console. By default, all services will try
to report metrics info to Influxdb and subsequently viewed from Grafana dashboard.&lt;/p&gt;

&lt;p&gt;If InfluxDB is not available this report will be a noop.&lt;/p&gt;

&lt;p&gt;In order to output to the right Influxdb instance, we need to externalize metrics.yml&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s create a new folder metrics under compose and config.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd ~/networknt/light-java-example/ms_chain/config/api_a
mkdir metrics
cp security/* metrics
cd ~/networknt/light-java-example/ms_chain/config/api_b
mkdir metrics
cp security/* metrics
cd ~/networknt/light-java-example/ms_chain/config/api_c
mkdir metrics
cp security/* metrics
cd ~/networknt/light-java-example/ms_chain/config/api_d
mkdir metrics

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we need to add the following metrics.yml to each metrics folder under config.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;description: Metrics handler configuration
enabled: true
influxdbProtocol: http
influxdbHost: influxdb
influxdbPort: 8086
influxdbName: metrics
influxdbUser: admin
influxdbPass: admin
reportInMinutes: 1

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now let&amp;rsquo;s start Influxdb and Grafana from docker-compose-metrics.yml in light-docker.
The light-docker repo should have been checked out at preparation step.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd ~/networknt/light-docker
docker-compose -f docker-compose-metrics.yml up
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;rsquo;s update ms_chain/compose to create a new compose under metrics&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd ~/networknt/light-java-example/ms_chain/compose
mkdir metrics

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now create a new compose file under metrics folder&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#
# docker-compose-app.yml
#

version: &#39;2&#39;

#
# Services
#
services:


    #
    # Microservice: API A
    #
    apia:
        build: ~/networknt/light-java-example/ms_chain/api_a/security/
        ports:
            - &amp;quot;7001:7001&amp;quot;
        networks:
            - localnet
        volumes:
            - ~/networknt/light-java-example/ms_chain/config/api_a/metrics:/config

    #
    # Microservice: API B
    #
    apib:
        build: ~/networknt/light-java-example/ms_chain/api_b/security/
        ports:
            - &amp;quot;7002:7002&amp;quot;
        networks:
            - localnet
        volumes:
            - ~/networknt/light-java-example/ms_chain/config/api_b/metrics:/config

    #
    # Microservice: API C
    #
    apic:
        build: ~/networknt/light-java-example/ms_chain/api_c/security/
        ports:
            - &amp;quot;7003:7003&amp;quot;
        networks:
            - localnet
        volumes:
            - ~/networknt/light-java-example/ms_chain/config/api_c/metrics:/config

    #
    # Microservice: API D
    #
    apid:
        build: ~/networknt/light-java-example/ms_chain/api_d/security/
        ports:
            - &amp;quot;7004:7004&amp;quot;
        networks:
            - localnet
        volumes:
            - ~/networknt/light-java-example/ms_chain/config/api_d/metrics:/config

#
# Networks
#
networks:
    localnet:
        external: true

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now shutdown the APP compose by CTRL+C and restart it.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd ~/networknt/light-java-example/ms_chain/compose/metrics
docker-compose -f docker-compose-app.yml up
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;rsquo;s use curl to access API A, this time I am using a long lived token I generated
from a utility.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;eyJraWQiOiIxMDAiLCJhbGciOiJSUzI1NiJ9.eyJpc3MiOiJ1cm46Y29tOm5ldHdvcmtudDpvYXV0aDI6djEiLCJhdWQiOiJ1cm46Y29tLm5ldHdvcmtudCIsImV4cCI6MTgwNjIwMDY2MSwianRpIjoibmQtb2ZZbWRIY0JZTUlEYU50MUFudyIsImlhdCI6MTQ5MDg0MDY2MSwibmJmIjoxNDkwODQwNTQxLCJ2ZXJzaW9uIjoiMS4wIiwidXNlcl9pZCI6IlN0ZXZlIiwidXNlcl90eXBlIjoiRU1QTE9ZRUUiLCJjbGllbnRfaWQiOiJmN2Q0MjM0OC1jNjQ3LTRlZmItYTUyZC00YzU3ODc0MjFlNzIiLCJzY29wZSI6WyJhcGlfYS53IiwiYXBpX2IudyIsImFwaV9jLnciLCJhcGlfZC53Iiwic2VydmVyLmluZm8uciJdfQ.SPHICXRY4SuUvWf0NYtwUrQ2-N-NeYT3b4CvxbzNl7D7GL5CF91G3siECrRBVexe0smBHHeiP3bq65rnCVFtwlYYqH6ZS5P7-AFiNcLBzSI9-OhV8JSf5sv381nk2f41IE4av2YUlgY0_mcIDo24ItnuPCxj0l49CAaLb7b1SHZJBQJANJTeQj-wgFsEqwafA-2wH2gehtH8CmOuuYfWO5t5IehP-zJNVT66E4UTRfvvZaJIvNTEQBWPpaZeeK6e56SyBqaLOR7duqJZ8a2UQZRWsDdIVt2Y5jGXQu1gyenIvCQbYLS6iglg6Xaco9emnYFopd2i3psathuX367fvw

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;curl -H &amp;quot;Authorization: Bearer eyJraWQiOiIxMDAiLCJhbGciOiJSUzI1NiJ9.eyJpc3MiOiJ1cm46Y29tOm5ldHdvcmtudDpvYXV0aDI6djEiLCJhdWQiOiJ1cm46Y29tLm5ldHdvcmtudCIsImV4cCI6MTgwNjIwMDY2MSwianRpIjoibmQtb2ZZbWRIY0JZTUlEYU50MUFudyIsImlhdCI6MTQ5MDg0MDY2MSwibmJmIjoxNDkwODQwNTQxLCJ2ZXJzaW9uIjoiMS4wIiwidXNlcl9pZCI6IlN0ZXZlIiwidXNlcl90eXBlIjoiRU1QTE9ZRUUiLCJjbGllbnRfaWQiOiJmN2Q0MjM0OC1jNjQ3LTRlZmItYTUyZC00YzU3ODc0MjFlNzIiLCJzY29wZSI6WyJhcGlfYS53IiwiYXBpX2IudyIsImFwaV9jLnciLCJhcGlfZC53Iiwic2VydmVyLmluZm8uciJdfQ.SPHICXRY4SuUvWf0NYtwUrQ2-N-NeYT3b4CvxbzNl7D7GL5CF91G3siECrRBVexe0smBHHeiP3bq65rnCVFtwlYYqH6ZS5P7-AFiNcLBzSI9-OhV8JSf5sv381nk2f41IE4av2YUlgY0_mcIDo24ItnuPCxj0l49CAaLb7b1SHZJBQJANJTeQj-wgFsEqwafA-2wH2gehtH8CmOuuYfWO5t5IehP-zJNVT66E4UTRfvvZaJIvNTEQBWPpaZeeK6e56SyBqaLOR7duqJZ8a2UQZRWsDdIVt2Y5jGXQu1gyenIvCQbYLS6iglg6Xaco9emnYFopd2i3psathuX367fvw&amp;quot; localhost:7001/v1/data
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;enable-logging&#34;&gt;Enable Logging&lt;/h2&gt;

&lt;h2 id=&#34;integration&#34;&gt;Integration&lt;/h2&gt;

&lt;h2 id=&#34;performance&#34;&gt;Performance&lt;/h2&gt;

&lt;h2 id=&#34;production&#34;&gt;Production&lt;/h2&gt;

&lt;h2 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h2&gt;
</description>
    </item>
    
    <item>
      <title>Microservices</title>
      <link>https://networknt.github.io/light-java/tutorials/microservices/</link>
      <pubDate>Sun, 09 Oct 2016 08:01:56 -0400</pubDate>
      
      <guid>https://networknt.github.io/light-java/tutorials/microservices/</guid>
      <description>

&lt;h2 id=&#34;introduction&#34;&gt;Introduction&lt;/h2&gt;

&lt;p&gt;These days light weight container like Docker is getting traction, more and more
API services are developed for docker container and deployed to the cloud. In this
environment, traditional heavy weight containers like Java EE and Spring are
losing ground as it doesn&amp;rsquo;t make sense to have a heavy weight container wrapped
with a light weight docker container. Docker and container orchestration tools
like Kubernetes and Docker Swarm are replacing all the functionalities Java EE
provides without hogging resources.&lt;/p&gt;

&lt;p&gt;There is an &lt;a href=&#34;https://www.gartner.com/doc/reprints?id=1-3N8E378&amp;amp;ct=161205&amp;amp;st=sb&#34;&gt;article&lt;/a&gt;
published by Gartner indicates that both Java EE and .NET are declining and will
be replaced very soon.&lt;/p&gt;

&lt;p&gt;Another clear trend is standalone Gateway is phasing out in the cloud environment
with docker containers as most of the traditional gateway features are replaced
by container orchestration tool and docker container management tools. In addition,
some of the cross cutting concerns gateway provided are addressed in API frameworks
like Light-Java.&lt;/p&gt;

&lt;h2 id=&#34;prepare-workspace&#34;&gt;Prepare workspace&lt;/h2&gt;

&lt;p&gt;All specifications and code of the services are on github.com but we are going to
redo it again by following the steps in the tutorial. Let&amp;rsquo;s first create a
workspace. I have created a directory named networknt under user directory.&lt;/p&gt;

&lt;p&gt;Checkout related projects.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd ~/networknt
git clone git@github.com:networknt/swagger-codegen.git
git clone git@github.com:networknt/light-java-example.git
git clone git@github.com:networknt/swagger.git
git clone git@github.com:networknt/light-oauth2.git
git clone git@github.com:networknt/light-docker.git

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As we are going to regenerate API A, B, C and D, let&amp;rsquo;s rename these folders from
light-java-example.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd ~/networknt/light-java-example
mv api_a api_a.bak
mv api_b api_b.bak
mv api_c api_c.bak
mv api_d api_d.bak
cd ..

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;specifications&#34;&gt;Specifications&lt;/h2&gt;

&lt;p&gt;Light Java Microservices Framework encourages Design Driven API building and
&lt;a href=&#34;https://github.com/OAI/OpenAPI-Specification&#34;&gt;OpenAPI Specification&lt;/a&gt; is the central
piece to drive the runtime for security and validation. Also, the specification
can be used to scaffold a running server project the first time so that developers
can focus their efforts on the domain business logic implementation without
worrying about how each component wired together.&lt;/p&gt;

&lt;p&gt;During the service implementation phase, specification might be changed and you can
regenerate the service codebase again without overwriting your handlers and test
cases for handlers.&lt;/p&gt;

&lt;p&gt;To create swagger specification, the best tool is
&lt;a href=&#34;http://swagger.io/swagger-editor/&#34;&gt;swagger-editor&lt;/a&gt; and I have an
&lt;a href=&#34;https://networknt.github.io/light-java/tools/swagger-editor/&#34;&gt;article&lt;/a&gt;
in tools section to describe how to use it.&lt;/p&gt;

&lt;p&gt;By following the &lt;a href=&#34;https://networknt.github.io/light-java/tools/swagger-editor/&#34;&gt;instructions&lt;/a&gt;
on how to use the editor, let&amp;rsquo;s create four API specifications in swagger repo.&lt;/p&gt;

&lt;p&gt;API A will call API B and API C to fulfill its request. API B will call API D
to fulfill its request.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;API A -&amp;gt; API B -&amp;gt; API D
      -&amp;gt; API C
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here is the API A swagger.yaml and others can be found at
&lt;a href=&#34;https://github.com/networknt/swagger&#34;&gt;https://github.com/networknt/swagger&lt;/a&gt; or swagger
folder in your workspace.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;swagger: &#39;2.0&#39;

info:
  version: &amp;quot;1.0.0&amp;quot;
  title: API A for microservices demo
  description: API A is called by consumer directly and it will call API B and API C to get data
  contact:
    email: stevehu@gmail.com
  license:
    name: &amp;quot;Apache 2.0&amp;quot;
    url: &amp;quot;http://www.apache.org/licenses/LICENSE-2.0.html&amp;quot;
host: a.networknt.com
schemes:
  - http
basePath: /v1

consumes:
  - application/json
produces:
  - application/json

paths:
  /data:
    get:
      description: Return an array of strings collected from down stream APIs
      operationId: listData
      responses:
        200:
          description: Successful response
          schema:
            title: ArrayOfStrings
            type: array
            items:
              type: string
      security:
        - a_auth:
          - api_a.w
          - api_a.r

securityDefinitions:
  a_auth:
    type: oauth2
    authorizationUrl: http://localhost:8080/oauth2/code
    flow: implicit
    scopes:
      api_a.w: write access
      api_a.r: read access
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As defined in the specification, API A will return a list of stings and it requires
scope api_a.r or scope api_a.w to access the endpoint /data.&lt;/p&gt;

&lt;h2 id=&#34;swagger-codegen&#34;&gt;Swagger-Codegen&lt;/h2&gt;

&lt;p&gt;Now we have four API swagger.yaml files available. Let&amp;rsquo;s use swagger-codegen
to start four projects in light-java-example. In normal API build, you
should create a repo for each API.&lt;/p&gt;

&lt;h4 id=&#34;build-light-java-generator&#34;&gt;Build Light Java Generator&lt;/h4&gt;

&lt;p&gt;As &lt;a href=&#34;https://github.com/swagger-api/swagger-codegen&#34;&gt;swagger-codegen&lt;/a&gt; doesn&amp;rsquo;t
support Java 8, I have forked it &lt;a href=&#34;https://github.com/networknt/swagger-codegen&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The project is cloned to the local already during the prepare stage. Let&amp;rsquo;s build it.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd swagger-codegen
mvn clean install -DskipTests
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;generate-first-project&#34;&gt;Generate first project&lt;/h4&gt;

&lt;p&gt;Now you have your swagger-codegen built, let&amp;rsquo;s generate a project. Assume that
swagger, light-java-example and swagger-codegen are in the same working
directory ~/networknt and you are in ~/networknt/swagger-codegen now.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;java -jar modules/swagger-codegen-cli/target/swagger-codegen-cli.jar generate -i ../swagger/api_a/swagger.yaml -l light-java -o ../light-java-example/api_a

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here is the generator output.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;steve@joy:~/networknt/swagger-codegen$ java -jar modules/swagger-codegen-cli/target/swagger-codegen-cli.jar generate -i ../swagger/api_a/swagger.yaml -l light-java -o ../light-java-example/api_a
Picked up JAVA_TOOL_OPTIONS: -Dconfig.dir=/home/steve/config
[main] INFO io.swagger.parser.Swagger20Parser - reading from ../swagger/api_a/swagger.yaml
[main] INFO io.swagger.codegen.AbstractGenerator - writing file /home/steve/networknt/swagger-codegen/../light-java-example/api_a/src/main/java/io/swagger/handler/DataGetHandler.java
[main] INFO io.swagger.codegen.AbstractGenerator - writing file /home/steve/networknt/swagger-codegen/../light-java-example/api_a/src/test/java/io/swagger/handler/DataGetHandlerTest.java
swaggerio.swagger.models.Swagger@40249765
[main] INFO io.swagger.codegen.AbstractGenerator - writing file /home/steve/networknt/swagger-codegen/../light-java-example/api_a/pom.xml
[main] INFO io.swagger.codegen.AbstractGenerator - writing file /home/steve/networknt/swagger-codegen/../light-java-example/api_a/README.md
[main] INFO io.swagger.codegen.AbstractGenerator - writing file /home/steve/networknt/swagger-codegen/../light-java-example/api_a/.gitignore
[main] INFO io.swagger.codegen.AbstractGenerator - writing file /home/steve/networknt/swagger-codegen/../light-java-example/api_a/Dockerfile
[main] INFO io.swagger.codegen.AbstractGenerator - writing file /home/steve/networknt/swagger-codegen/../light-java-example/api_a/src/main/resources/config/swagger.json
[main] INFO io.swagger.codegen.AbstractGenerator - writing file /home/steve/networknt/swagger-codegen/../light-java-example/api_a/src/main/java/io/swagger/PathHandlerProvider.java
[main] INFO io.swagger.codegen.AbstractGenerator - writing file /home/steve/networknt/swagger-codegen/../light-java-example/api_a/src/test/java/io/swagger/handler/TestServer.java
[main] INFO io.swagger.codegen.AbstractGenerator - writing file /home/steve/networknt/swagger-codegen/../light-java-example/api_a/src/main/resources/META-INF/services/com.networknt.server.HandlerProvider
[main] INFO io.swagger.codegen.AbstractGenerator - writing file /home/steve/networknt/swagger-codegen/../light-java-example/api_a/src/main/resources/META-INF/services/com.networknt.handler.MiddlewareHandler
[main] INFO io.swagger.codegen.AbstractGenerator - writing file /home/steve/networknt/swagger-codegen/../light-java-example/api_a/src/main/resources/META-INF/services/com.networknt.handler.StartupHookProvider
[main] INFO io.swagger.codegen.AbstractGenerator - writing file /home/steve/networknt/swagger-codegen/../light-java-example/api_a/src/main/resources/META-INF/services/com.networknt.handler.ShutdownHookProvider
[main] INFO io.swagger.codegen.DefaultGenerator - writing file /home/steve/networknt/swagger-codegen/../light-java-example/api_a/src/main/resources/config/server.json
[main] INFO io.swagger.codegen.DefaultGenerator - writing file /home/steve/networknt/swagger-codegen/../light-java-example/api_a/src/main/resources/config/security.json
[main] INFO io.swagger.codegen.DefaultGenerator - writing file /home/steve/networknt/swagger-codegen/../light-java-example/api_a/src/main/resources/config/oauth/primary.crt
[main] INFO io.swagger.codegen.DefaultGenerator - writing file /home/steve/networknt/swagger-codegen/../light-java-example/api_a/src/main/resources/config/oauth/secondary.crt
[main] INFO io.swagger.codegen.DefaultGenerator - writing file /home/steve/networknt/swagger-codegen/../light-java-example/api_a/src/main/resources/logback.xml
[main] INFO io.swagger.codegen.AbstractGenerator - writing file /home/steve/networknt/swagger-codegen/../light-java-example/api_a/.swagger-codegen-ignore
[main] INFO io.swagger.codegen.AbstractGenerator - writing file /home/steve/networknt/swagger-codegen/../light-java-example/api_a/LICENSE

&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;build-and-run-the-mock-api&#34;&gt;Build and run the mock API&lt;/h4&gt;

&lt;p&gt;And now you have a new project created in light-java-example. Let&amp;rsquo;s build
it and run the test cases. If everything is OK, start the server.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd ..
cd light-java-example/api_a
mvn clean install
mvn exec:exec
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;rsquo;s test the API A by issuing the following command&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;curl localhost:8080/v1/data
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;By default the generated response example will be returned.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[ &amp;quot;aeiou&amp;quot; ]
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;generate-other-apis&#34;&gt;Generate other APIs&lt;/h4&gt;

&lt;p&gt;Let&amp;rsquo;s kill the API A by Ctrl+C and move to the swagger-codegen folder again. Follow
the above steps to generate other APIs. Make sure you are in swagger_codegen
directory.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;java -jar modules/swagger-codegen-cli/target/swagger-codegen-cli.jar generate -i ../swagger/api_b/swagger.yaml -l light-java -o ../light-java-example/api_b
java -jar modules/swagger-codegen-cli/target/swagger-codegen-cli.jar generate -i ../swagger/api_c/swagger.yaml -l light-java -o ../light-java-example/api_c
java -jar modules/swagger-codegen-cli/target/swagger-codegen-cli.jar generate -i ../swagger/api_d/swagger.yaml -l light-java -o ../light-java-example/api_d

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now you have four APIs generated from four OpenAPI specifications. Let&amp;rsquo;s check
them in. Note that you might not have write access to this repo, so you can ignore
this step.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd ../light-java-example
git add .
git commit -m &amp;quot;checkin 4 apis&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;handlers&#34;&gt;Handlers&lt;/h2&gt;

&lt;p&gt;Now these APIs are working if you start them and they will output the mock responses
generated based on the API specifications. Let&amp;rsquo;s take a look at the API handler itself
and update it based on our business logic.&lt;/p&gt;

&lt;h4 id=&#34;api-d&#34;&gt;API D&lt;/h4&gt;

&lt;p&gt;Let&amp;rsquo;s take a look at the generated PathHandlerProvider.java in
api_d/src/main/java/io/swagger/&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package io.swagger;

import com.networknt.config.Config;
import com.networknt.server.HandlerProvider;
import io.undertow.Handlers;
import io.undertow.server.HttpHandler;
import io.undertow.server.HttpServerExchange;
import io.undertow.util.Methods;
import io.swagger.handler.*;

public class PathHandlerProvider implements HandlerProvider {

    public HttpHandler getHandler() {
        HttpHandler handler = Handlers.routing()
            .add(Methods.GET, &amp;quot;/v1/data&amp;quot;, new DataGetHandler())
        ;
        return handler;
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is the only class that routes each endpoint defined in specification to a handler
instance. Because we only have one endpoint /v1/data@get there is only one route added
to the handler chain. And there is a handler generated in the handler subfolder to
handle request that has the url matched to this endpoint.&lt;/p&gt;

&lt;p&gt;The generated handler is named &amp;ldquo;DataGetHandler&amp;rdquo; and it returns example response generated
based on the swagger specification. Here is the generated handler code.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package io.swagger.handler;

import io.undertow.server.HttpHandler;
import io.undertow.server.HttpServerExchange;
import io.undertow.util.HttpString;
import java.util.HashMap;
import java.util.Map;
import org.apache.commons.lang3.StringEscapeUtils;

public class DataGetHandler implements HttpHandler {

    public void handleRequest(HttpServerExchange exchange) throws Exception {
        Map&amp;lt;String, Object&amp;gt; examples = new HashMap&amp;lt;String, Object&amp;gt;();
        examples.put(&amp;quot;application/json&amp;quot;, StringEscapeUtils.unescapeHtml4(&amp;quot;[ &amp;amp;quot;aeiou&amp;amp;quot; ]&amp;quot;));
        if(examples.size() &amp;gt; 0) {
            exchange.getResponseHeaders().add(new HttpString(&amp;quot;Content-Type&amp;quot;), &amp;quot;application/json&amp;quot;);
            exchange.getResponseSender().send((String)examples.get(&amp;quot;application/json&amp;quot;));
        } else {
            exchange.endExchange();
        }
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;rsquo;s update it to an array of strings that indicates the response comes from API D.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package io.swagger.handler;

import com.networknt.config.Config;
import io.undertow.server.HttpHandler;
import io.undertow.server.HttpServerExchange;
import io.undertow.util.HttpString;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import org.apache.commons.lang3.StringEscapeUtils;

public class DataGetHandler implements HttpHandler {

    public void handleRequest(HttpServerExchange exchange) throws Exception {
        List&amp;lt;String&amp;gt; messages = new ArrayList&amp;lt;String&amp;gt;();
        messages.add(&amp;quot;API D: Message 1&amp;quot;);
        messages.add(&amp;quot;API D: Message 2&amp;quot;);
        exchange.getResponseSender().send(Config.getInstance().getMapper().writeValueAsString(messages));
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now, let&amp;rsquo;s build it and start the server. Make sure there is only one server
started at any time as all servers are listening to the same port.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd api_d
mvn clean package exec:exec
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Test it with curl.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;curl localhost:8080/v1/data
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And the result is&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[&amp;quot;API D: Message 1&amp;quot;,&amp;quot;API D: Message 2&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;api-c&#34;&gt;API C&lt;/h4&gt;

&lt;p&gt;Let&amp;rsquo;s shutdown API D and update API C DataGetHandler to&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package io.swagger.handler;

import com.networknt.config.Config;
import io.undertow.server.HttpHandler;
import io.undertow.server.HttpServerExchange;
import io.undertow.util.HttpString;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import org.apache.commons.lang3.StringEscapeUtils;

public class DataGetHandler implements HttpHandler {

    public void handleRequest(HttpServerExchange exchange) throws Exception {
        List&amp;lt;String&amp;gt; messages = new ArrayList&amp;lt;String&amp;gt;();
        messages.add(&amp;quot;API C: Message 1&amp;quot;);
        messages.add(&amp;quot;API C: Message 2&amp;quot;);
        exchange.getResponseSender().send(Config.getInstance().getMapper().writeValueAsString(messages));
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Restart API C server and test the endpoint /v1/data&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd api_c
mvn clean install exec:exec
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;From another terminal window run:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;curl localhost:8080/v1/data
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And the result is&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[&amp;quot;API C: Message 1&amp;quot;,&amp;quot;API C: Message 2&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;api-b&#34;&gt;API B&lt;/h4&gt;

&lt;p&gt;Let&amp;rsquo;s shutdown API C and complete API B. API B will call API D to fulfill its
request so it needs to use Light Java Client module to call API D.&lt;/p&gt;

&lt;p&gt;Now let&amp;rsquo;s update the generated DataGetHandler.java to this.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package io.swagger.handler;

import com.fasterxml.jackson.core.type.TypeReference;
import com.networknt.client.Client;
import com.networknt.config.Config;
import com.networknt.exception.ClientException;
import io.undertow.server.HttpHandler;
import io.undertow.server.HttpServerExchange;
import io.undertow.util.HttpString;

import java.io.IOException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import org.apache.commons.lang3.StringEscapeUtils;
import org.apache.http.client.methods.CloseableHttpResponse;
import org.apache.http.client.methods.HttpGet;
import org.apache.http.impl.client.CloseableHttpClient;

public class DataGetHandler implements HttpHandler {

    static String CONFIG_NAME = &amp;quot;api_b&amp;quot;;
    static String apidUrl = (String)Config.getInstance().getJsonMapConfig(CONFIG_NAME).get(&amp;quot;api_d_endpoint&amp;quot;);

    public void handleRequest(HttpServerExchange exchange) throws Exception {
        List&amp;lt;String&amp;gt; list = new ArrayList&amp;lt;String&amp;gt;();
        try {
            CloseableHttpClient client = Client.getInstance().getSyncClient();
            HttpGet httpGet = new HttpGet(apidUrl);
            CloseableHttpResponse response = client.execute(httpGet);
            int responseCode = response.getStatusLine().getStatusCode();
            if(responseCode != 200){
                throw new Exception(&amp;quot;Failed to call API D: &amp;quot; + responseCode);
            }
            List&amp;lt;String&amp;gt; apidList = (List&amp;lt;String&amp;gt;) Config.getInstance().getMapper().readValue(response.getEntity().getContent(),
                    new TypeReference&amp;lt;List&amp;lt;String&amp;gt;&amp;gt;(){});
            list.addAll(apidList);
        } catch (ClientException e) {
            throw new Exception(&amp;quot;Client Exception: &amp;quot;, e);
        } catch (IOException e) {
            throw new Exception(&amp;quot;IOException:&amp;quot;, e);
        }
        // now add API B specific messages
        list.add(&amp;quot;API B: Message 1&amp;quot;);
        list.add(&amp;quot;API B: Message 2&amp;quot;);
        exchange.getResponseSender().send(Config.getInstance().getMapper().writeValueAsString(list));
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As API B only calls one API, here sync client is used. As API B will interact
with API D and it requires configuration changes to make it work. Let&amp;rsquo;s wait
until the next step to test it.&lt;/p&gt;

&lt;h4 id=&#34;api-a&#34;&gt;API A&lt;/h4&gt;

&lt;p&gt;API A will call API B and API C to fulfill its request. Now let&amp;rsquo;s update the
generated DataGetHandler.java code to&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package io.swagger.handler;

import com.fasterxml.jackson.core.type.TypeReference;
import com.networknt.client.Client;
import com.networknt.config.Config;
import com.networknt.exception.ClientException;
import io.undertow.server.HttpHandler;
import io.undertow.server.HttpServerExchange;
import io.undertow.util.HttpString;

import java.io.IOException;
import java.util.*;
import java.util.concurrent.CountDownLatch;

import org.apache.commons.lang3.StringEscapeUtils;
import org.apache.http.HttpResponse;
import org.apache.http.client.methods.HttpGet;
import org.apache.http.concurrent.FutureCallback;
import org.apache.http.impl.nio.client.CloseableHttpAsyncClient;

public class DataGetHandler implements HttpHandler {

    static String CONFIG_NAME = &amp;quot;api_a&amp;quot;;
    static String apibUrl = (String)Config.getInstance().getJsonMapConfig(CONFIG_NAME).get(&amp;quot;api_b_endpoint&amp;quot;);
    static String apicUrl = (String)Config.getInstance().getJsonMapConfig(CONFIG_NAME).get(&amp;quot;api_c_endpoint&amp;quot;);

    public void handleRequest(HttpServerExchange exchange) throws Exception {
        List&amp;lt;String&amp;gt; list = new Vector&amp;lt;String&amp;gt;();
        final HttpGet[] requests = new HttpGet[] {
                new HttpGet(apibUrl),
                new HttpGet(apicUrl),
        };
        try {
            CloseableHttpAsyncClient client = Client.getInstance().getAsyncClient();
            final CountDownLatch latch = new CountDownLatch(requests.length);
            for (final HttpGet request: requests) {
                Client.getInstance().propagateHeaders(request, exchange);
                client.execute(request, new FutureCallback&amp;lt;HttpResponse&amp;gt;() {
                    @Override
                    public void completed(final HttpResponse response) {
                        try {
                            List&amp;lt;String&amp;gt; apiList = (List&amp;lt;String&amp;gt;) Config.getInstance().getMapper().readValue(response.getEntity().getContent(),
                                    new TypeReference&amp;lt;List&amp;lt;String&amp;gt;&amp;gt;(){});
                            list.addAll(apiList);
                        } catch (IOException e) {
                            e.printStackTrace();
                        }
                        latch.countDown();
                    }

                    @Override
                    public void failed(final Exception ex) {
                        ex.printStackTrace();
                        latch.countDown();
                    }

                    @Override
                    public void cancelled() {
                        System.out.println(&amp;quot;cancelled&amp;quot;);
                        latch.countDown();
                    }
                });
            }
            latch.await();
        } catch (ClientException e) {
            e.printStackTrace();
            throw new Exception(&amp;quot;ClientException:&amp;quot;, e);
        }
        // now add API A specific messages
        list.add(&amp;quot;API A: Message 1&amp;quot;);
        list.add(&amp;quot;API A: Message 2&amp;quot;);
        exchange.getResponseSender().send(Config.getInstance().getMapper().writeValueAsString(list));
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;At this moment, we have all four APIs completed but they are not going to be
started at the same time as generated server.json uses the same port 8080. The
next step is to change the configuration and test it out.&lt;/p&gt;

&lt;h2 id=&#34;configuration&#34;&gt;Configuration&lt;/h2&gt;

&lt;p&gt;Light-Java has a module called Config and it is responsible to read config
files from environmental property specified directory, classpath, API
resources/config folder and module resources/config folder in that sequence as
default File System based configuration. It can be extended to other config like
config server, distributed cache and http server etc.&lt;/p&gt;

&lt;p&gt;To make things simpler, let&amp;rsquo;s update the server.json in API A, B, C, D to bind to
different port in order to start them on the same localhost. The server.json can
be found in src/main/resources/config folder of each project.&lt;/p&gt;

&lt;p&gt;Find the server.json at api_a/src/main/resources/config and update the content
to&lt;/p&gt;

&lt;p&gt;API A&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
  &amp;quot;description&amp;quot;: &amp;quot;server config&amp;quot;,
  &amp;quot;ip&amp;quot;: &amp;quot;0.0.0.0&amp;quot;,
  &amp;quot;port&amp;quot;: 7001
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;API B&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
  &amp;quot;description&amp;quot;: &amp;quot;server config&amp;quot;,
  &amp;quot;ip&amp;quot;: &amp;quot;0.0.0.0&amp;quot;,
  &amp;quot;port&amp;quot;: 7002
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;API C&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
  &amp;quot;description&amp;quot;: &amp;quot;server config&amp;quot;,
  &amp;quot;ip&amp;quot;: &amp;quot;0.0.0.0&amp;quot;,
  &amp;quot;port&amp;quot;: 7003
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;API D&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
  &amp;quot;description&amp;quot;: &amp;quot;server config&amp;quot;,
  &amp;quot;ip&amp;quot;: &amp;quot;0.0.0.0&amp;quot;,
  &amp;quot;port&amp;quot;: 7004
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As API A is calling API B and C, we need to create a config file for API B and C
endpoints. Let&amp;rsquo;s create a new file named api_a.json in api_a/src/main/resources/config&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
  &amp;quot;description&amp;quot;: &amp;quot;api_a config&amp;quot;,
  &amp;quot;api_b_endpoint&amp;quot;: &amp;quot;http://localhost:7002/v1/data&amp;quot;,
  &amp;quot;api_c_endpoint&amp;quot;: &amp;quot;http://localhost:7003/v1/data&amp;quot;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As API B is calling API D, we need to create a config file for API D endpoint. Let&amp;rsquo;s
create a new file named api_b.json in api_b/src/main/resources/config&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
  &amp;quot;description&amp;quot;: &amp;quot;api_b config&amp;quot;,
  &amp;quot;api_d_endpoint&amp;quot;: &amp;quot;http://localhost:7004/v1/data&amp;quot;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now let&amp;rsquo;s start all four servers on four terminals and test them out.&lt;/p&gt;

&lt;p&gt;API D&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd api_d
mvn clean install
mvn exec:exec
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;API C&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd ../api_c
mvn clean install exec:exec
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;API B&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd ../api_b
mvn clean install exec:exec
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;API A&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd ../api_a
mvn clean install exec:exec
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now let&amp;rsquo;s call API A and see what we can get.&lt;/p&gt;

&lt;p&gt;Start another terminal and run&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; curl localhost:7001/v1/data
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And you should see the result like this.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[&amp;quot;API C: Message 1&amp;quot;,&amp;quot;API C: Message 2&amp;quot;,&amp;quot;API D: Message 1&amp;quot;,&amp;quot;API D: Message 2&amp;quot;,&amp;quot;API B: Message 1&amp;quot;,&amp;quot;API B: Message 2&amp;quot;,&amp;quot;API A: Message 1&amp;quot;,&amp;quot;API A: Message 2&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;performance-without-security&#34;&gt;Performance without security&lt;/h2&gt;

&lt;p&gt;Now let&amp;rsquo;s see if these servers are performing with
&lt;a href=&#34;https://github.com/wg/wrk&#34;&gt;wrk&lt;/a&gt;. To learn how to use it, please see my
article in tools &lt;a href=&#34;https://networknt.github.io/light-java/tools/wrk-perf/&#34;&gt;here&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Assume you have wrk installed, run the following command.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;wrk -t4 -c800 -d30s http://localhost:7001/v1/data

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And here is what I got on my i5 desktop&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;steve@joy:~/tool/wrk$ wrk -t4 -c800 -d30s http://localhost:7001/v1/data
Running 30s test @ http://localhost:7001/v1/data
  4 threads and 800 connections
  Thread Stats   Avg      Stdev     Max   +/- Stdev
    Latency   254.60ms  308.66ms   2.00s    84.11%
    Req/Sec     1.24k     1.19k    3.90k    80.27%
  147302 requests in 30.08s, 34.42MB read
  Socket errors: connect 0, read 0, write 0, timeout 251
Requests/sec:   4897.60
Transfer/sec:      1.14MB
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now let&amp;rsquo;s push the server to its limit&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; wrk -t4 -c128 -d30s http://localhost:7001 -s pipeline.lua --latency -- /v1/data 16
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And here is the result without any tuning.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;steve@joy:~/tool/wrk$ wrk -t4 -c128 -d30s http://localhost:7001 -s pipeline.lua --latency -- /v1/data 16
Running 30s test @ http://localhost:7001
  4 threads and 128 connections
  Thread Stats   Avg      Stdev     Max   +/- Stdev
    Latency    55.14ms  130.69ms   1.61s    13.96%
    Req/Sec     2.92k     1.24k    5.17k    64.86%
  Latency Distribution
     50%    0.00us
     75%    0.00us
     90%    0.00us
     99%    0.00us
  331488 requests in 30.03s, 77.45MB read
Requests/sec:  11039.99
Transfer/sec:      2.58MB
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;enable-oauth2-security&#34;&gt;Enable OAuth2 Security&lt;/h2&gt;

&lt;p&gt;So far, we&amp;rsquo;ve started four servers and tested them successfully; however,
these servers are not protected by OAuth2 JWT tokens as it is turned off
by default in the generated code.&lt;/p&gt;

&lt;p&gt;Before we turn on the security, we need to have &lt;a href=&#34;https://github.com/networknt/light-oauth2&#34;&gt;light-oauth2&lt;/a&gt;
server up and running so that these servers can get JWT token in real
time.&lt;/p&gt;

&lt;p&gt;The easiest way to run light-oauth2 server is through docker but let&amp;rsquo;s
build it locally this time.&lt;/p&gt;

&lt;p&gt;Go to your working directory and go to the light-oauth2 folder cloned in the prepare stage.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd light-oauth2
mvn clean package exec:exec
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now let&amp;rsquo;s enable the jwt token verification and scope verification for all
APIs except API A. For API A we want to enableVerifyJwt to true but
enableVerifyScope to false so that we can use a long lived token to test from
curl without getting new tokens each time.&lt;/p&gt;

&lt;p&gt;Open src/main/resources/config/security.json in api_b/api_c/api_d folder and
update enableVerifyJwt and enableVerifyScope to true. The following is what
looks like for API B, C and D.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
  &amp;quot;description&amp;quot;: &amp;quot;security configuration&amp;quot;,
  &amp;quot;enableVerifyJwt&amp;quot;: true,
  &amp;quot;enableVerifyScope&amp;quot;: true,
  &amp;quot;enableMockJwt&amp;quot;: false,
  &amp;quot;jwt&amp;quot;: {
    &amp;quot;certificate&amp;quot;: {
      &amp;quot;100&amp;quot;: &amp;quot;oauth/primary.crt&amp;quot;,
      &amp;quot;101&amp;quot;: &amp;quot;oauth/secondary.crt&amp;quot;
    },
    &amp;quot;clockSkewInSeconds&amp;quot;: 60
  },
  &amp;quot;logJwtToken&amp;quot;: true,
  &amp;quot;logClientUserScope&amp;quot;: false
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is what looks like for API A src/main/resources/config/security.json&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
  &amp;quot;description&amp;quot;: &amp;quot;security configuration&amp;quot;,
  &amp;quot;enableVerifyJwt&amp;quot;: true,
  &amp;quot;enableVerifyScope&amp;quot;: false,
  &amp;quot;enableMockJwt&amp;quot;: false,
  &amp;quot;jwt&amp;quot;: {
    &amp;quot;certificate&amp;quot;: {
      &amp;quot;100&amp;quot;: &amp;quot;oauth/primary.crt&amp;quot;,
      &amp;quot;101&amp;quot;: &amp;quot;oauth/secondary.crt&amp;quot;
    },
    &amp;quot;clockSkewInSeconds&amp;quot;: 60
  },
  &amp;quot;logJwtToken&amp;quot;: true,
  &amp;quot;logClientUserScope&amp;quot;: false
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now make sure that client.json in both API A and API B are configured correctly
to get the right token from light-oauth2 server with the correct scopes. The generated code doesn&amp;rsquo;t
have client.json so you need to create these files in src/main/resources/config folder in order to
overwrite the default client.json from Client module.&lt;/p&gt;

&lt;p&gt;The client_id and client_secret are set up in clients.json in light-oauth2
already &lt;a href=&#34;https://github.com/networknt/light-oauth2/blob/master/src/main/resources/config/clients.json&#34;&gt;here&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;API A client&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  &amp;quot;fe5dadd9-34ad-430f-a8f7-c75e81cc5d7b&amp;quot;: {
    &amp;quot;client_secret&amp;quot;:&amp;quot;GXkHy-1aSPyo4pst8WBWbg&amp;quot;,
    &amp;quot;scope&amp;quot;: &amp;quot;api_b.r api_b.w api_c.r api_c.w&amp;quot;,
    &amp;quot;redirect_uri&amp;quot;: &amp;quot;http://localhost:8080/oauth&amp;quot;
  },
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;API B client&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  &amp;quot;10a0a743-4674-4a9d-8867-db63ad4c8b4e&amp;quot;: {
    &amp;quot;client_secret&amp;quot;:&amp;quot;tcahI1dvT1OsxXxg-IB_-w&amp;quot;,
    &amp;quot;scope&amp;quot;: &amp;quot;api_d.r api_d.w&amp;quot;,
    &amp;quot;redirect_uri&amp;quot;: &amp;quot;http://localhost:8080/oauth&amp;quot;
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now let&amp;rsquo;s create client.json on both API A and API B to reflect the above info.
This is what looks like in API A src/main/resources/config/client.json&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
  &amp;quot;description&amp;quot;: &amp;quot;client configuration, all timing is milli-second&amp;quot;,
  &amp;quot;sync&amp;quot;: {
    &amp;quot;maxConnectionTotal&amp;quot;: 100,
    &amp;quot;maxConnectionPerRoute&amp;quot;: 10,
    &amp;quot;routes&amp;quot;: {
      &amp;quot;api.google.com&amp;quot;: 20,
      &amp;quot;api.facebook.com&amp;quot;: 10
    },
    &amp;quot;timeout&amp;quot;: 10000,
    &amp;quot;keepAlive&amp;quot;: 15000
  },
  &amp;quot;async&amp;quot;: {
    &amp;quot;maxConnectionTotal&amp;quot;: 100,
    &amp;quot;maxConnectionPerRoute&amp;quot;: 10,
    &amp;quot;routes&amp;quot;: {
      &amp;quot;api.google.com&amp;quot;: 20,
      &amp;quot;api.facebook.com&amp;quot;: 10
    },
    &amp;quot;reactor&amp;quot;: {
      &amp;quot;ioThreadCount&amp;quot;: 1,
      &amp;quot;connectTimeout&amp;quot;: 10000,
      &amp;quot;soTimeout&amp;quot;: 10000
    },
    &amp;quot;timeout&amp;quot;: 10000,
    &amp;quot;keepAlive&amp;quot;: 15000
  },
  &amp;quot;tls&amp;quot;: {
    &amp;quot;verifyHostname&amp;quot;: false,
    &amp;quot;loadTrustStore&amp;quot;: false,
    &amp;quot;trustStore&amp;quot;: &amp;quot;trust.keystore&amp;quot;,
    &amp;quot;trustPass&amp;quot;: &amp;quot;password&amp;quot;,
    &amp;quot;loadKeyStore&amp;quot;: false,
    &amp;quot;keyStore&amp;quot;: &amp;quot;key.jks&amp;quot;,
    &amp;quot;keyPass&amp;quot;: &amp;quot;password&amp;quot;
  },
  &amp;quot;oauth&amp;quot;: {
    &amp;quot;tokenRenewBeforeExpired&amp;quot;: 600000,
    &amp;quot;expiredRefreshRetryDelay&amp;quot;: 5000,
    &amp;quot;earlyRefreshRetryDelay&amp;quot;: 30000,
    &amp;quot;server_url&amp;quot;: &amp;quot;http://localhost:8888&amp;quot;,
    &amp;quot;timeout&amp;quot;: 5000,
    &amp;quot;ignoreSSLErrors&amp;quot;: false,
    &amp;quot;authorization_code&amp;quot;: {
      &amp;quot;uri&amp;quot;: &amp;quot;/oauth2/token&amp;quot;,
      &amp;quot;client_id&amp;quot;: &amp;quot;fe5dadd9-34ad-430f-a8f7-c75e81cc5d7b&amp;quot;,
      &amp;quot;client_secret&amp;quot;: &amp;quot;GXkHy-1aSPyo4pst8WBWbg&amp;quot;,
      &amp;quot;redirect_uri&amp;quot;: &amp;quot;https://localhost:8080/authorization_code&amp;quot;,
      &amp;quot;scope&amp;quot;: [
        &amp;quot;api_b.r&amp;quot;,
        &amp;quot;api_b.w&amp;quot;,
        &amp;quot;api_c.r&amp;quot;,
        &amp;quot;api_c.w&amp;quot;
      ]
    },
    &amp;quot;client_credentials&amp;quot;: {
      &amp;quot;uri&amp;quot;: &amp;quot;/oauth2/token&amp;quot;,
      &amp;quot;client_id&amp;quot;: &amp;quot;fe5dadd9-34ad-430f-a8f7-c75e81cc5d7b&amp;quot;,
      &amp;quot;client_secret&amp;quot;: &amp;quot;GXkHy-1aSPyo4pst8WBWbg&amp;quot;,
      &amp;quot;scope&amp;quot;: [
        &amp;quot;api_b.r&amp;quot;,
        &amp;quot;api_b.w&amp;quot;,
        &amp;quot;api_c.r&amp;quot;,
        &amp;quot;api_c.w&amp;quot;
      ]
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And this is what looks like in API B client.json&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
  &amp;quot;description&amp;quot;: &amp;quot;client configuration, all timing is milli-second&amp;quot;,
  &amp;quot;sync&amp;quot;: {
    &amp;quot;maxConnectionTotal&amp;quot;: 100,
    &amp;quot;maxConnectionPerRoute&amp;quot;: 10,
    &amp;quot;routes&amp;quot;: {
      &amp;quot;api.google.com&amp;quot;: 20,
      &amp;quot;api.facebook.com&amp;quot;: 10
    },
    &amp;quot;timeout&amp;quot;: 10000,
    &amp;quot;keepAlive&amp;quot;: 15000
  },
  &amp;quot;async&amp;quot;: {
    &amp;quot;maxConnectionTotal&amp;quot;: 100,
    &amp;quot;maxConnectionPerRoute&amp;quot;: 10,
    &amp;quot;routes&amp;quot;: {
      &amp;quot;api.google.com&amp;quot;: 20,
      &amp;quot;api.facebook.com&amp;quot;: 10
    },
    &amp;quot;reactor&amp;quot;: {
      &amp;quot;ioThreadCount&amp;quot;: 1,
      &amp;quot;connectTimeout&amp;quot;: 10000,
      &amp;quot;soTimeout&amp;quot;: 10000
    },
    &amp;quot;timeout&amp;quot;: 10000,
    &amp;quot;keepAlive&amp;quot;: 15000
  },
  &amp;quot;tls&amp;quot;: {
    &amp;quot;verifyHostname&amp;quot;: false,
    &amp;quot;loadTrustStore&amp;quot;: false,
    &amp;quot;trustStore&amp;quot;: &amp;quot;trust.keystore&amp;quot;,
    &amp;quot;trustPass&amp;quot;: &amp;quot;password&amp;quot;,
    &amp;quot;loadKeyStore&amp;quot;: false,
    &amp;quot;keyStore&amp;quot;: &amp;quot;key.jks&amp;quot;,
    &amp;quot;keyPass&amp;quot;: &amp;quot;password&amp;quot;
  },
  &amp;quot;oauth&amp;quot;: {
    &amp;quot;tokenRenewBeforeExpired&amp;quot;: 600000,
    &amp;quot;expiredRefreshRetryDelay&amp;quot;: 5000,
    &amp;quot;earlyRefreshRetryDelay&amp;quot;: 30000,
    &amp;quot;server_url&amp;quot;: &amp;quot;http://localhost:8888&amp;quot;,
    &amp;quot;timeout&amp;quot;: 5000,
    &amp;quot;ignoreSSLErrors&amp;quot;: false,
    &amp;quot;authorization_code&amp;quot;: {
      &amp;quot;uri&amp;quot;: &amp;quot;/oauth2/token&amp;quot;,
      &amp;quot;client_id&amp;quot;: &amp;quot;10a0a743-4674-4a9d-8867-db63ad4c8b4e&amp;quot;,
      &amp;quot;client_secret&amp;quot;: &amp;quot;tcahI1dvT1OsxXxg-IB_-w&amp;quot;,
      &amp;quot;redirect_uri&amp;quot;: &amp;quot;https://localhost:8080/authorization_code&amp;quot;,
      &amp;quot;scope&amp;quot;: [
        &amp;quot;api_d.r&amp;quot;,
        &amp;quot;api_d.w&amp;quot;
      ]
    },
    &amp;quot;client_credentials&amp;quot;: {
      &amp;quot;uri&amp;quot;: &amp;quot;/oauth2/token&amp;quot;,
      &amp;quot;client_id&amp;quot;: &amp;quot;10a0a743-4674-4a9d-8867-db63ad4c8b4e&amp;quot;,
      &amp;quot;client_secret&amp;quot;: &amp;quot;tcahI1dvT1OsxXxg-IB_-w&amp;quot;,
      &amp;quot;scope&amp;quot;: [
        &amp;quot;api_d.r&amp;quot;,
        &amp;quot;api_d.w&amp;quot;
      ]
    }
  }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With client.json updated in both API A and API B, we need to update the code
to assign scope token during runtime.&lt;/p&gt;

&lt;p&gt;Open API A DataGetHandler and one line before client.execute(&amp;hellip;).&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    Client.getInstance().propagateHeaders(request, exchange);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here is the updated file&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package io.swagger.handler;

import com.fasterxml.jackson.core.type.TypeReference;
import com.networknt.client.Client;
import com.networknt.config.Config;
import com.networknt.exception.ClientException;
import io.undertow.server.HttpHandler;
import io.undertow.server.HttpServerExchange;
import io.undertow.util.HttpString;

import java.io.IOException;
import java.util.*;
import java.util.concurrent.CountDownLatch;

import org.apache.commons.lang3.StringEscapeUtils;
import org.apache.http.HttpResponse;
import org.apache.http.client.methods.HttpGet;
import org.apache.http.concurrent.FutureCallback;
import org.apache.http.impl.nio.client.CloseableHttpAsyncClient;

public class DataGetHandler implements HttpHandler {

    static String CONFIG_NAME = &amp;quot;api_a&amp;quot;;
    static String apibUrl = (String)Config.getInstance().getJsonMapConfig(CONFIG_NAME).get(&amp;quot;api_b_endpoint&amp;quot;);
    static String apicUrl = (String)Config.getInstance().getJsonMapConfig(CONFIG_NAME).get(&amp;quot;api_c_endpoint&amp;quot;);

    public void handleRequest(HttpServerExchange exchange) throws Exception {
        List&amp;lt;String&amp;gt; list = new Vector&amp;lt;String&amp;gt;();
        final HttpGet[] requests = new HttpGet[] {
                new HttpGet(apibUrl),
                new HttpGet(apicUrl),
        };
        try {
            CloseableHttpAsyncClient client = Client.getInstance().getAsyncClient();
            final CountDownLatch latch = new CountDownLatch(requests.length);
            for (final HttpGet request: requests) {
                Client.getInstance().propagateHeaders(request, exchange);
                client.execute(request, new FutureCallback&amp;lt;HttpResponse&amp;gt;() {
                    @Override
                    public void completed(final HttpResponse response) {
                        try {
                            List&amp;lt;String&amp;gt; apiList = (List&amp;lt;String&amp;gt;) Config.getInstance().getMapper().readValue(response.getEntity().getContent(),
                                    new TypeReference&amp;lt;List&amp;lt;String&amp;gt;&amp;gt;(){});
                            list.addAll(apiList);
                        } catch (IOException e) {
                            e.printStackTrace();
                        }
                        latch.countDown();
                    }

                    @Override
                    public void failed(final Exception ex) {
                        ex.printStackTrace();
                        latch.countDown();
                    }

                    @Override
                    public void cancelled() {
                        System.out.println(&amp;quot;cancelled&amp;quot;);
                        latch.countDown();
                    }
                });
            }
            latch.await();
        } catch (ClientException e) {
            e.printStackTrace();
            throw new Exception(&amp;quot;ClientException:&amp;quot;, e);
        }
        // now add API A specific messages
        list.add(&amp;quot;API A: Message 1&amp;quot;);
        list.add(&amp;quot;API A: Message 2&amp;quot;);
        exchange.getResponseSender().send(Config.getInstance().getMapper().writeValueAsString(list));
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Open API B DataGetHandler and add one line and the end result is:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package io.swagger.handler;

import com.fasterxml.jackson.core.type.TypeReference;
import com.networknt.client.Client;
import com.networknt.config.Config;
import com.networknt.exception.ClientException;
import io.undertow.server.HttpHandler;
import io.undertow.server.HttpServerExchange;
import io.undertow.util.HttpString;

import java.io.IOException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import org.apache.commons.lang3.StringEscapeUtils;
import org.apache.http.client.methods.CloseableHttpResponse;
import org.apache.http.client.methods.HttpGet;
import org.apache.http.impl.client.CloseableHttpClient;

public class DataGetHandler implements HttpHandler {

    static String CONFIG_NAME = &amp;quot;api_b&amp;quot;;
    static String apidUrl = (String)Config.getInstance().getJsonMapConfig(CONFIG_NAME).get(&amp;quot;api_d_endpoint&amp;quot;);

    public void handleRequest(HttpServerExchange exchange) throws Exception {
        List&amp;lt;String&amp;gt; list = new ArrayList&amp;lt;String&amp;gt;();
        try {
            CloseableHttpClient client = Client.getInstance().getSyncClient();
            HttpGet httpGet = new HttpGet(apidUrl);
            Client.getInstance().propagateHeaders(httpGet, exchange);
            CloseableHttpResponse response = client.execute(httpGet);
            int responseCode = response.getStatusLine().getStatusCode();
            if(responseCode != 200){
                throw new Exception(&amp;quot;Failed to call API D: &amp;quot; + responseCode);
            }
            List&amp;lt;String&amp;gt; apidList = (List&amp;lt;String&amp;gt;) Config.getInstance().getMapper().readValue(response.getEntity().getContent(),
                    new TypeReference&amp;lt;List&amp;lt;String&amp;gt;&amp;gt;(){});
            list.addAll(apidList);
        } catch (ClientException e) {
            throw new Exception(&amp;quot;Client Exception: &amp;quot;, e);
        } catch (IOException e) {
            throw new Exception(&amp;quot;IOException:&amp;quot;, e);
        }
        // now add API B specific messages
        list.add(&amp;quot;API B: Message 1&amp;quot;);
        list.add(&amp;quot;API B: Message 2&amp;quot;);
        exchange.getResponseSender().send(Config.getInstance().getMapper().writeValueAsString(list));
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;rsquo;s start these servers and test it. Don&amp;rsquo;t forget to start light-oauth2 server.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd light-oauth2
mvn package exec:exec
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Run the following command.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;curl -H &amp;quot;Authorization: Bearer eyJraWQiOiIxMDAiLCJhbGciOiJSUzI1NiJ9.eyJpc3MiOiJ1cm46Y29tOm5ldHdvcmtudDpvYXV0aDI6djEiLCJhdWQiOiJ1cm46Y29tLm5ldHdvcmtudCIsImV4cCI6MTc5NDgwMDYzOSwianRpIjoiWFhlQmpJYXUwUk5ZSTl3dVF0MWxtUSIsImlhdCI6MTQ3OTQ0MDYzOSwibmJmIjoxNDc5NDQwNTE5LCJ2ZXJzaW9uIjoiMS4wIiwidXNlcl9pZCI6InN0ZXZlIiwidXNlcl90eXBlIjoiRU1QTE9ZRUUiLCJjbGllbnRfaWQiOiJmN2Q0MjM0OC1jNjQ3LTRlZmItYTUyZC00YzU3ODc0MjFlNzIiLCJzY29wZSI6WyJ3cml0ZTpwZXRzIiwicmVhZDpwZXRzIl19.f5XdkmhOoHT2lgTobqVGPp2aWUv_ItA0tqyLHC_CeMbmwzPvREqb5-oJ9T_m3VwRcJlPTh8xTdSjrLITXClaQFE4Y0bT8C-u6bb38uT-NQ5mjUjLrFQYHCF6GqwL7YkwQt_rshEqtrDFe1T4HoEL_9FHbOxf3MSJ39UKq0Ef_9mHXkn4Y-SHfdapeuUWc_4dDPdxzEdzbqmf1WSOOgTuM5O5F2fK4p_ix8LQl0H3AnMZIhIDyygQEnYPxEG-u35gwh503wfxio6buIf0b2Kku2PXPE36lethZwIVaPTncEcY5OPxfBxXuy-Wq-YQizd7NnpJTteHYbdQXupjK7NDvQ&amp;quot; localhost:7001/v1/data
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And here is the result.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[&amp;quot;API C: Message 1&amp;quot;,&amp;quot;API C: Message 2&amp;quot;,&amp;quot;API D: Message 1&amp;quot;,&amp;quot;API D: Message 2&amp;quot;,&amp;quot;API B: Message 1&amp;quot;,&amp;quot;API B: Message 2&amp;quot;,&amp;quot;API A: Message 1&amp;quot;,&amp;quot;API A: Message 2&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;At this moment, all four APIs are protected by JWT token and API B, C, D are projected by scope additionally.&lt;/p&gt;

&lt;h2 id=&#34;dockerization&#34;&gt;Dockerization&lt;/h2&gt;

&lt;h2 id=&#34;integration&#34;&gt;Integration&lt;/h2&gt;

&lt;h2 id=&#34;performance&#34;&gt;Performance&lt;/h2&gt;

&lt;h2 id=&#34;production&#34;&gt;Production&lt;/h2&gt;

&lt;h2 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h2&gt;
</description>
    </item>
    
  </channel>
</rss>