<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Middleware-rsses on Light Java - The fastest Java API Framework</title>
    <link>https://networknt.github.io/light-java/middleware/index.xml</link>
    <description>Recent content in Middleware-rsses on Light Java - The fastest Java API Framework</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>Released under the MIT license</copyright>
    <lastBuildDate>Fri, 17 Feb 2017 14:10:28 -0500</lastBuildDate>
    <atom:link href="https://networknt.github.io/light-java/middleware/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Rate Limiting</title>
      <link>https://networknt.github.io/light-java/middleware/limit/</link>
      <pubDate>Fri, 17 Feb 2017 14:10:28 -0500</pubDate>
      
      <guid>https://networknt.github.io/light-java/middleware/limit/</guid>
      <description>

&lt;p&gt;Although our framework can handle potential millions requests per second, for
some public facing APIs, it might be a good idea to enable this handler to
limit the concurrent request to certain level in order to avoid DDOS attacks.&lt;/p&gt;

&lt;p&gt;As this handler will impact the overall performance a little bit, it is not
configured as default in the swagger-codegen. You must manually enable it
in your API with the following steps.&lt;/p&gt;

&lt;h2 id=&#34;dependency&#34;&gt;Dependency&lt;/h2&gt;

&lt;p&gt;In order to use this handler, the following dependency need to be added to
pom.xml in your project.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;            &amp;lt;dependency&amp;gt;
                &amp;lt;groupId&amp;gt;com.networknt&amp;lt;/groupId&amp;gt;
                &amp;lt;artifactId&amp;gt;limit&amp;lt;/artifactId&amp;gt;
                &amp;lt;version&amp;gt;${version.light-java}&amp;lt;/version&amp;gt;
            &amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;service&#34;&gt;Service&lt;/h2&gt;

&lt;p&gt;As this middleware is not plugged in by default, we need to add it into
com.networknt.handler.MiddlewareHandler in src/main/resources/META-INF/services
folder. As this rate limiting handler needs to be failed fast, it need to be
put right after ExceptionHandler and MetricsHandler. The reason it is after
MetricsHandler is to capture 513 error code in InfluxDB and Grafana for
monitoring on production.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#Traceability Put traceabilityId into response header from request header if it exists
com.networknt.traceability.TraceabilityHandler
#Rate Limiting
com.networknt.limit.LimitHandler
#Metrics In order to calculate response time accurately, this needs to be the second.
com.networknt.metrics.MetricsHandler
#Exception Global exception handler that needs to be called first.
com.networknt.exception.ExceptionHandler

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;config&#34;&gt;Config&lt;/h2&gt;

&lt;p&gt;Here is the configuration file for rate limiting.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
  &amp;quot;description&amp;quot;: &amp;quot;Rate Limit Handler&amp;quot;,
  &amp;quot;enabled&amp;quot;: false,
  &amp;quot;concurrentRequest&amp;quot;: 1000,
  &amp;quot;queueSize&amp;quot;: -1
}

&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;enabled true to enable it and false to disable it.&lt;/li&gt;
&lt;li&gt;concurrentRequest number of concurrent request to be limited.&lt;/li&gt;
&lt;li&gt;queueSize -1 unlimited queue size which might use a lot of memory. &amp;gt; 1 integer will limit the requests to be queued and once queue is full, 513 will be returned for new requests.&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Request and Response Dump</title>
      <link>https://networknt.github.io/light-java/middleware/dump/</link>
      <pubDate>Mon, 06 Feb 2017 21:40:01 -0500</pubDate>
      
      <guid>https://networknt.github.io/light-java/middleware/dump/</guid>
      <description>&lt;p&gt;This is a handler that dumps the entire request and response into a log file. It
should only be used in development mode for debugging purpose as it is very slow.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Correlation Id</title>
      <link>https://networknt.github.io/light-java/middleware/correlation/</link>
      <pubDate>Mon, 06 Feb 2017 09:59:28 -0500</pubDate>
      
      <guid>https://networknt.github.io/light-java/middleware/correlation/</guid>
      <description>

&lt;p&gt;This is a handler that checks if X-Correlation-Id exists in request header. If it doesn&amp;rsquo;t exist
it will generate a UUID and put it into the request header. During API to API calls, this header
will be passed to the next API by Client module.&lt;/p&gt;

&lt;h1 id=&#34;generating&#34;&gt;Generating&lt;/h1&gt;

&lt;p&gt;The correlationId is very useful in microservices architecture as there are multiple services
involved in a same client request. When logs are aggregated into a centralized tool, it is
very important there is an unique identifier to associate logs from multiple services for the
same request. The Id is an UUID and must be generated in the first service called from client.&lt;/p&gt;

&lt;h1 id=&#34;passing&#34;&gt;Passing&lt;/h1&gt;

&lt;p&gt;Since the first service generates the Id, it must be passed to other services somehow so that
subsequent services can use it to log their messages. In our &lt;a href=&#34;https://networknt.github.io/light-java/other/client/&#34;&gt;client&lt;/a&gt;
module, it passes the correlationId from the current request header to the request to the next
service.&lt;/p&gt;

&lt;h1 id=&#34;logging&#34;&gt;Logging&lt;/h1&gt;

&lt;p&gt;This handler gets the X-Correlation-Id from request header or generate one if it doesn&amp;rsquo;t
exist in the request header. After that, it puts it into the org.slf4j.MDC so that logback
can put it into the log for every logging statement.&lt;/p&gt;

&lt;h1 id=&#34;logback-xml&#34;&gt;logback.xml&lt;/h1&gt;

&lt;p&gt;In the generated logback.xml, the cId is part of the appender config as pattern &amp;ldquo;%X{cId}&amp;rdquo;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    &amp;lt;appender name=&amp;quot;stdout&amp;quot; class=&amp;quot;ch.qos.logback.core.ConsoleAppender&amp;quot;&amp;gt;
        &amp;lt;!-- encoders are assigned the type
             ch.qos.logback.classic.encoder.PatternLayoutEncoder by default --&amp;gt;
        &amp;lt;encoder&amp;gt;
            &amp;lt;pattern&amp;gt;%d{HH:mm:ss.SSS} [%thread] %X{cId} %-5level %logger{36} - %msg%n&amp;lt;/pattern&amp;gt;
        &amp;lt;/encoder&amp;gt;
    &amp;lt;/appender&amp;gt;

    &amp;lt;appender name=&amp;quot;log&amp;quot; class=&amp;quot;ch.qos.logback.core.FileAppender&amp;quot;&amp;gt;
        &amp;lt;File&amp;gt;target/test.log&amp;lt;/File&amp;gt;
        &amp;lt;Append&amp;gt;false&amp;lt;/Append&amp;gt;
        &amp;lt;layout class=&amp;quot;ch.qos.logback.classic.PatternLayout&amp;quot;&amp;gt;
            &amp;lt;Pattern&amp;gt;%d{HH:mm:ss.SSS} [%thread] %X{cId} %-5level %class{36}:%L %M - %msg%n&amp;lt;/Pattern&amp;gt;
        &amp;lt;/layout&amp;gt;
    &amp;lt;/appender&amp;gt;

&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Traceability</title>
      <link>https://networknt.github.io/light-java/middleware/traceability/</link>
      <pubDate>Sun, 06 Nov 2016 10:24:22 -0500</pubDate>
      
      <guid>https://networknt.github.io/light-java/middleware/traceability/</guid>
      <description>

&lt;p&gt;#&lt;/p&gt;

&lt;p&gt;For microservices architecture, a request sent from client may pass
through several services to the backend respository/Book of Record
and then response is returned in the reverse path. If there is an
error in the call tree, we need to identify where is the problem
during runtime. Also, for some mission critical applications, the
entire call tree must be in the audit log to meet regulatory compliance
requirement. For example, banking applications.&lt;/p&gt;

&lt;p&gt;The framework has two tracing IDs built in and X-Traceability-Id is one
of them that handled by this middleware component. Another one is
X-Correlation-Id which is documented in &lt;a href=&#34;https://networknt.github.io/light-java/middleware/correlation/&#34;&gt;correlation&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;X-Traceability-Id is generated by the original client and might not
be unique across the API domain. It is unique for that particular
client though. It is usually a sequence number generated from database
or a UUID. The usage of this id is to debug broken transactions as every
service will have this id logged once if the service is called and will
return this id in response header to the caller.&lt;/p&gt;

&lt;p&gt;Every API/Service is responsible to pass the X-Traceability-Id (from
request header) to the next service (set the request header by Client
when calling another service).&lt;/p&gt;

&lt;p&gt;Not all client will supply traceability_id so this is an optional field
in the request header. If it doesn&amp;rsquo;t exist, do nothing. If it does exist,
the framework is responsible to pass it to the next API in the chain or
pass to the Book of Record.&lt;/p&gt;

&lt;p&gt;It is recommended that X-Traceability-Id should be persisted in Backend
Repository/Book of Record. However, this might not be possible for some
legacy application, i.e. mainframe applications.&lt;/p&gt;

&lt;p&gt;It should only be logged once in the audit log once your API processing
is done and successful.&lt;/p&gt;

&lt;h1 id=&#34;configuration&#34;&gt;Configuration&lt;/h1&gt;

&lt;p&gt;The configuration for this handler is very simple, just control if this
handler is enabled or not.
It will only be plugged into the request/response chain if enabled is
true in the traceability.json&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
  &amp;quot;description&amp;quot;: &amp;quot;Traceability Handler&amp;quot;,
  &amp;quot;enabled&amp;quot;: true
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;calling-sequence&#34;&gt;Calling sequence&lt;/h1&gt;

&lt;p&gt;This handler will be loaded after metric handler.&lt;/p&gt;

&lt;h1 id=&#34;dependencies&#34;&gt;Dependencies&lt;/h1&gt;

&lt;p&gt;This handler set the response header from request header; however, to make
it work across services, it depends the following middleware or component
to work.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://networknt.github.io/light-java/middleware/audit/&#34;&gt;Audit&lt;/a&gt;
to log the traceabilityId to the audit log file.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://networknt.github.io/light-java/other/client/&#34;&gt;Client&lt;/a&gt;
to pass the X-Traceability-Id to the next service through HttpRequest Header.&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>sanitizer</title>
      <link>https://networknt.github.io/light-java/middleware/sanitizer/</link>
      <pubDate>Sun, 23 Oct 2016 10:35:04 -0400</pubDate>
      
      <guid>https://networknt.github.io/light-java/middleware/sanitizer/</guid>
      <description>

&lt;h1 id=&#34;introduction&#34;&gt;Introduction&lt;/h1&gt;

&lt;p&gt;This is a middleware that addresses cross site scripting concerns. It encodes the header
and body according to the configuration. As body encoding depends on
&lt;a href=&#34;https://networknt.github.io/light-java/middleware/body/&#34;&gt;Body&lt;/a&gt; middleware, it has to be
plugged into the request/response chain after Body.&lt;/p&gt;

&lt;h1 id=&#34;configuration&#34;&gt;Configuration&lt;/h1&gt;

&lt;p&gt;Here is the default configuration sanitizer.json&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
  &amp;quot;description&amp;quot;: &amp;quot;Sanitize request for cross site scripting during runtime&amp;quot;,
  &amp;quot;enabled&amp;quot;: true,
  &amp;quot;sanitizeBody&amp;quot;: true,
  &amp;quot;sanitizeHeader&amp;quot;: true
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If enabled is false, this middleware won&amp;rsquo;t be loaded during server startup.
sanitizeBody and sanitizeHeader control if body and header need to be sanitized or both.&lt;/p&gt;

&lt;h1 id=&#34;query-parameters&#34;&gt;Query Parameters&lt;/h1&gt;

&lt;p&gt;In other platforms especially JEE containers, query parameters need to be sanitized as well.
However, I have found that Undertow does sanitize special characters in query parameters. This
is why this handler doesn&amp;rsquo;t do anything about query parameters.&lt;/p&gt;

&lt;h1 id=&#34;encode-library&#34;&gt;Encode Library&lt;/h1&gt;

&lt;p&gt;The library used for cross site scripting sanitization is from &lt;a href=&#34;https://www.owasp.org/index.php/Cross-site_Scripting_(XSS&#34;&gt;https://www.owasp.org/index.php/Cross-site_Scripting_(XSS&lt;/a&gt;)
and the library can be found at &lt;a href=&#34;https://github.com/OWASP/owasp-java-encoder&#34;&gt;https://github.com/OWASP/owasp-java-encoder&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;encode-level&#34;&gt;Encode Level&lt;/h1&gt;

&lt;p&gt;The encode level we are using for both header and body is &amp;ldquo;forJavaScriptSource&amp;rdquo;. This gives us
certain level of confident and it won&amp;rsquo;t mess up header and body in most the case.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Metrics</title>
      <link>https://networknt.github.io/light-java/middleware/metrics/</link>
      <pubDate>Sat, 15 Oct 2016 20:42:32 -0400</pubDate>
      
      <guid>https://networknt.github.io/light-java/middleware/metrics/</guid>
      <description>

&lt;h2 id=&#34;introduction&#34;&gt;Introduction&lt;/h2&gt;

&lt;p&gt;Metrics handler collects the API runtime information and report to Influxdb periodically
(5 minutes to 15 minutes based on the volume of the API). A Grafana instance is hooked to Influxdb
to output the metrics on dashboard from two different perspectives:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Client oriented - client centric info to show how many APIs to call and each API runtime info.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;API oriented - API centric info to show how many clients is calling this API.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;configuration&#34;&gt;Configuration&lt;/h2&gt;

&lt;p&gt;Here is an example of configuration.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
  &amp;quot;description&amp;quot;: &amp;quot;Metrics handler configuration&amp;quot;,
  &amp;quot;enabled&amp;quot;: true,
  &amp;quot;influxdbHost&amp;quot;: &amp;quot;localhost&amp;quot;,
  &amp;quot;influxdbPort&amp;quot;: 8086,
  &amp;quot;influxdbName&amp;quot;: &amp;quot;metrics&amp;quot;,
  &amp;quot;influxdbUser&amp;quot;: &amp;quot;admin&amp;quot;,
  &amp;quot;influxdbPass&amp;quot;: &amp;quot;admin&amp;quot;,
  &amp;quot;reportInMinutes&amp;quot;: 5
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;influxdb-and-grafana&#34;&gt;InfluxDB and Grafana&lt;/h2&gt;

&lt;p&gt;Here is the docker-compose.yml&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;influxdb:
  image: influxdb:latest
  container_name: influxdb
  ports:
    - &amp;quot;8083:8083&amp;quot;
    - &amp;quot;8086:8086&amp;quot;

grafana:
  image: grafana/grafana:latest
  container_name: grafana
  ports:
    - &amp;quot;3000:3000&amp;quot;
  links:
    - influxdb
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;metrics-collected&#34;&gt;Metrics Collected&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;https://networknt.github.io/light-java/images/measurements.png&#34; alt=&#34;measurements&#34; /&gt;&lt;/p&gt;

&lt;p&gt;As you can see, there two perspectives in collecting metrics info. The measurements started with clientId are client
centric info and the measurements started with API name are API centric info.&lt;/p&gt;

&lt;p&gt;Currently, we are collecting 5 metrics each.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://networknt.github.io/light-java/images/client_metrics.png&#34; alt=&#34;client metrics&#34; /&gt;&lt;/p&gt;

&lt;p&gt;This is request count for client f7d42348-c647-4efb-a52d-4c5787421e72&lt;/p&gt;

&lt;p&gt;The first column is timestamp and value column is the value for this time series. Other columns are tags and they
are endpoint, hostname/container id, ipAddress and version.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://networknt.github.io/light-java/images/api_metrics.png&#34; alt=&#34;api metrics&#34; /&gt;&lt;/p&gt;

&lt;p&gt;This is request count for API swagger_petstore.&lt;/p&gt;

&lt;p&gt;The first column is timestamp and value column is the value for this time series. Other columns are tags and they
are endpoint, hostname/container id, ipAddress and version.&lt;/p&gt;

&lt;h2 id=&#34;customization&#34;&gt;Customization&lt;/h2&gt;

&lt;p&gt;The default implementation is based on InfluxDB and Grafana which are the most popular combination
for docker containers. However, the database and dashboard can be replaced easily with another
reporter implementation. To replace it, change the MetricsHandler to use another reporter instead of
InfluxDB.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Swagger Validator</title>
      <link>https://networknt.github.io/light-java/middleware/swagger-validator/</link>
      <pubDate>Wed, 12 Oct 2016 19:13:19 -0400</pubDate>
      
      <guid>https://networknt.github.io/light-java/middleware/swagger-validator/</guid>
      <description>

&lt;p&gt;This handler is part of the &lt;a href=&#34;https://github.com/networknt/light-java-rest&#34;&gt;light-java-rest&lt;/a&gt;
which is built on top of light-java but focused on RESTful API only.&lt;/p&gt;

&lt;p&gt;It encourages design driven implementation so swagger specification should be
done before the implementation starts. With the swagger-codegen light-java
generator, the server stub can be generated and start running within minutes.
However, we cannot rely on generator for validation as specification will be
changed along the life cycle of the API. This is why we have provided a validator
that works on top of the specification at runtime. In this way, the generator
should only be used once and the validator will take the latest specification and
validate according the specification at runtime.&lt;/p&gt;

&lt;h1 id=&#34;fail-fast&#34;&gt;Fail fast&lt;/h1&gt;

&lt;p&gt;As you may noticed that our Status object only supports one code and message.
This is the indication the framework validation is designed as fail fast.
Whenever there is an error, the server will stop processing the request and
return the error to the consumer immediately. There are two reasons on this
design:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Security - you don&amp;rsquo;t want to return so many errors if someone is trying
to hack your server.&lt;/li&gt;
&lt;li&gt;Performance - you don&amp;rsquo;t want to spend resource to handle invalid request
to the next step.&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&#34;validatorhandler&#34;&gt;ValidatorHandler&lt;/h1&gt;

&lt;p&gt;This is the entry point of the validator and it is injected during server
start up if validator.json enableValidator is true. By default, only
RequestValidator will be called. However, ResponseValidator can be enabled
by setting enableResponseValidator to true in validator.json.&lt;/p&gt;

&lt;h1 id=&#34;requestvalidator&#34;&gt;RequestValidator&lt;/h1&gt;

&lt;p&gt;It will validate the following:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;uri&lt;/li&gt;
&lt;li&gt;method&lt;/li&gt;
&lt;li&gt;header&lt;/li&gt;
&lt;li&gt;query parameters&lt;/li&gt;
&lt;li&gt;path parameters&lt;/li&gt;
&lt;li&gt;body if available&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;When necessary, &lt;a href=&#34;https://github.com/networknt/json-schema-validator&#34;&gt;json-schema-validator&lt;/a&gt;
will be called to do json schema validation.&lt;/p&gt;

&lt;h1 id=&#34;responsevalidator&#34;&gt;ResponseValidator&lt;/h1&gt;

&lt;p&gt;It will validate the following:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;header&lt;/li&gt;
&lt;li&gt;response code&lt;/li&gt;
&lt;li&gt;body if available&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;when necessary, &lt;a href=&#34;https://github.com/networknt/json-schema-validator&#34;&gt;json-schema-validator&lt;/a&gt;
will be called.&lt;/p&gt;

&lt;h1 id=&#34;schemavalidator&#34;&gt;SchemaValidator&lt;/h1&gt;

&lt;p&gt;If schema is defined in swagger.json, then the &lt;a href=&#34;https://github.com/networknt/json-schema-validator&#34;&gt;json-schema-validator&lt;/a&gt;
will be called to validate the input against a json schema defined in draft v4.&lt;/p&gt;

&lt;h1 id=&#34;test&#34;&gt;Test&lt;/h1&gt;

&lt;p&gt;In order to test validator, the test suite starts a light-java server and serves
petstore api for testing. It is a demo on how to unit test your API during
development.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Swagger Meta</title>
      <link>https://networknt.github.io/light-java/middleware/swagger-meta/</link>
      <pubDate>Wed, 12 Oct 2016 19:10:34 -0400</pubDate>
      
      <guid>https://networknt.github.io/light-java/middleware/swagger-meta/</guid>
      <description>

&lt;h1 id=&#34;introduction&#34;&gt;Introduction&lt;/h1&gt;

&lt;p&gt;This handler is part of the &lt;a href=&#34;https://github.com/networknt/light-java-rest&#34;&gt;light-java-rest&lt;/a&gt;
which is built on top of light-java but focused on RESTful API only.&lt;/p&gt;

&lt;p&gt;It is designed based on swagger specification so it is our best interest to utilize
the swagger.json to its full potential. Currently there are two components are using
the swagger specification during runtime.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://networknt.github.io/light-java/middleware/swagger-security/&#34;&gt;swagger-security&lt;/a&gt; -
Verify scope in the JWT token against scope defined in swagger specification if
scope verification is true.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://networknt.github.io/light-java/middleware/swagger-validator/&#34;&gt;swagger-validator&lt;/a&gt; -
Validate request and response based on the definition in swagger specification for
the uri and method.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;As you have noticed, both components need to have swagger operation available
based on the current request uri and method combination.&lt;/p&gt;

&lt;h1 id=&#34;cache&#34;&gt;Cache&lt;/h1&gt;

&lt;p&gt;A specification file swagger.json should be in the config folder of your API
implementation and it will be loaded to memory with SwaggerHelper during server
start up. It will be cached in memory until the server is restarted.&lt;/p&gt;

&lt;h1 id=&#34;normalized-path&#34;&gt;Normalized Path&lt;/h1&gt;

&lt;p&gt;In order to match the incoming request path to the paths defined in the swagger
specification, all paths are normalized before matching action. SwaggerHelper
provides an API to match the request path to the paths in swagger specification.&lt;/p&gt;

&lt;h1 id=&#34;swaggerhandler&#34;&gt;SwaggerHandler&lt;/h1&gt;

&lt;p&gt;This is an HttpHandler to parse the swagger spec based on the request uri and
method and attach an SwaggerOperation object to the exchange. The swagger-security
and swagger-validator modules are using it to do their jobs without parsing the
swagger.json second time.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Swagger Security</title>
      <link>https://networknt.github.io/light-java/middleware/swagger-security/</link>
      <pubDate>Wed, 12 Oct 2016 19:07:43 -0400</pubDate>
      
      <guid>https://networknt.github.io/light-java/middleware/swagger-security/</guid>
      <description>

&lt;p&gt;This handler is part of the &lt;a href=&#34;https://github.com/networknt/light-java-rest&#34;&gt;light-java-rest&lt;/a&gt;
which is built on top of light-java but focused on RESTful API only.&lt;/p&gt;

&lt;p&gt;It supports OAuth2 with JWT token distributed verification and can be extended to
other authentication and authorization approaches.&lt;/p&gt;

&lt;h1 id=&#34;jwtverifyhandler&#34;&gt;JwtVerifyHandler&lt;/h1&gt;

&lt;p&gt;This is the handler that is injected during server start up if security.json
enableVerifyJwt is true. It does further scope verification if enableVerifyScope
is true against swagger specification.&lt;/p&gt;

&lt;h1 id=&#34;distributed-jwt-verification&#34;&gt;Distributed JWT verification&lt;/h1&gt;

&lt;p&gt;Unlike simple web token, the resource server has to contact Authorization server
to validate the bearer token. JWT can be verified by resource server as long as
the token signing certificate is available at resource server.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Exception Handler</title>
      <link>https://networknt.github.io/light-java/middleware/exception/</link>
      <pubDate>Wed, 12 Oct 2016 19:03:24 -0400</pubDate>
      
      <guid>https://networknt.github.io/light-java/middleware/exception/</guid>
      <description>

&lt;p&gt;If any handler throws an exception within the handler chain, that exception
will bubble up to the undertow server and eventually a 500 response will be
sent to the consumer. In order to change the behaviour, an exception handler
is provided to handle ApiException and other uncaught exceptions.&lt;/p&gt;

&lt;p&gt;Please note that developers should capture any checked exceptions including
ApiException in their handlers and return a specific error code to help client
to debug what is going on on the server. This exception handler is designed
as last defense and only should be used to something unexpected.&lt;/p&gt;

&lt;h1 id=&#34;runtime-exception&#34;&gt;Runtime Exception&lt;/h1&gt;

&lt;p&gt;Any runtime exception will be captured and return a standard 500 error with
error code ERR10010.&lt;/p&gt;

&lt;h1 id=&#34;uncaught-exception&#34;&gt;Uncaught Exception&lt;/h1&gt;

&lt;p&gt;Any checked exception that is not handled by handlers in the handler chain
is captured and return a 400 error with error code ERR10011&lt;/p&gt;

&lt;h1 id=&#34;apiexception&#34;&gt;ApiException&lt;/h1&gt;

&lt;p&gt;ApiException has a status object and it will return to consume the data defined
in the status object.&lt;/p&gt;

&lt;h1 id=&#34;logging&#34;&gt;Logging&lt;/h1&gt;

&lt;p&gt;Exception handler will log the exception with stacktrace.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Body Parser</title>
      <link>https://networknt.github.io/light-java/middleware/body/</link>
      <pubDate>Wed, 12 Oct 2016 18:57:17 -0400</pubDate>
      
      <guid>https://networknt.github.io/light-java/middleware/body/</guid>
      <description>

&lt;h1 id=&#34;introduction&#34;&gt;Introduction&lt;/h1&gt;

&lt;p&gt;Body is an HttpHandler to parse the body according to the content type int the
request header and attach the parsed result into the exchange so that subsequent
handlers will use it directly.&lt;/p&gt;

&lt;p&gt;Only POST, PUT and PATCH methods can have body and currently only JSON is supported
as only light-java-rest is built on top of light-java at the moment. In the future,
other content type will be supported.&lt;/p&gt;

&lt;p&gt;It needs content type header to be started with &amp;ldquo;application/json&amp;rdquo;. If the content
type is correct, it will parse it to List or Map and put it into REQUEST_BODY
exchange attachment.&lt;/p&gt;

&lt;p&gt;If content type is missing or if it is not started as &amp;ldquo;application/json&amp;rdquo;, the body
won&amp;rsquo;t be parsed and this handler will just call next handler in the chain.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://networknt.github.io/light-java/middleware/sanitizer/&#34;&gt;Sanitizer&lt;/a&gt;
and &lt;a href=&#34;https://networknt.github.io/light-java/middleware/swagger-validator/&#34;&gt;Swagger Validator&lt;/a&gt;
depend on this middleware.&lt;/p&gt;

&lt;h1 id=&#34;configuration&#34;&gt;Configuration&lt;/h1&gt;

&lt;p&gt;Here is an example of configuration which has a flag to enable or disable it.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
  &amp;quot;description&amp;quot;: &amp;quot;Body parser handler&amp;quot;,
  &amp;quot;enabled&amp;quot;: true
}

&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Audit</title>
      <link>https://networknt.github.io/light-java/middleware/audit/</link>
      <pubDate>Wed, 12 Oct 2016 18:48:58 -0400</pubDate>
      
      <guid>https://networknt.github.io/light-java/middleware/audit/</guid>
      <description>

&lt;p&gt;There are two built-in audit handlers that write logs into audit.log that setup
in the logback appender.&lt;/p&gt;

&lt;h1 id=&#34;simpleaudithandler&#34;&gt;SimpleAuditHandler&lt;/h1&gt;

&lt;p&gt;Only logs several fields from request header and the fields are configurable.
Optional, it can log response status and response time.&lt;/p&gt;

&lt;h1 id=&#34;fullaudithandler&#34;&gt;FullAuditHandler&lt;/h1&gt;

&lt;p&gt;Dump every thing from request and response. This is mainly a development tool
and may be used on production for some of the APIs without performance concerns.&lt;/p&gt;

&lt;h1 id=&#34;customized-handler&#34;&gt;Customized Handler&lt;/h1&gt;

&lt;p&gt;For some users that need special audit logic or other channel to redirect the audit
to, they can create their own audit handler and replace the default audit handler in
/src/main/resources/META-INF/services/com.networknt.handler.MiddlewareHandler&lt;/p&gt;

&lt;p&gt;Before updating this file, please read this [document]()&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Middleware Handlers</title>
      <link>https://networknt.github.io/light-java/middleware/</link>
      <pubDate>Fri, 07 Oct 2016 22:02:13 -0400</pubDate>
      
      <guid>https://networknt.github.io/light-java/middleware/</guid>
      <description>

&lt;h1 id=&#34;introduction&#34;&gt;Introduction&lt;/h1&gt;

&lt;p&gt;light-java is a Java API framework based on undertow http core that supports
swagger code generation and runtime request validation.&lt;/p&gt;

&lt;p&gt;It contains the following components:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://networknt.github.io/light-java/middleware/swagger-meta/&#34;&gt;swagger-meta&lt;/a&gt; is a
middleware that load swagger at runtime and parse it based on the request uri and method and
attached the swagger data related to the current endpoint into the exchange for subsequent
handlers to use.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://networknt.github.io/light-java/middleware/swagger-security/&#34;&gt;swagger-security&lt;/a&gt;
Oauth2 JWT token verification distributed in every microservice. Also, there is an OAuth2
server based on light-java released &lt;a href=&#34;https://github.com/networknt/light-oauth2&#34;&gt;here&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://networknt.github.io/light-java/middleware/swagger-validator/&#34;&gt;swagger-validator&lt;/a&gt;
validates request based on the swagger.json for uri parameters, query parameters and body
which is based on &lt;a href=&#34;https://github.com/networknt/json-schema-validator&#34;&gt;json-schema-validator&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://networknt.github.io/light-java/middleware/audit/&#34;&gt;audit&lt;/a&gt; logs most important info
about request and response into audit.log in JSON format with config file that controls which
fieds to be logged.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://networknt.github.io/light-java/middleware/body/&#34;&gt;body&lt;/a&gt; is a body parser middleware
that is responsible for parsing the content of the request based on Content-Type in the
request header.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://networknt.github.io/light-java/middleware/exception/&#34;&gt;exception&lt;/a&gt; is a generic
exception handler that handles runtime exception, ApiException and other checked exception
if they are not handled properly in the handler chain.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://networknt.github.io/light-java/middleware/metrics/&#34;&gt;metrics&lt;/a&gt; is a module that collects
API runtime info based on clientId and API name. The metrics info is sent to InfluxDB and
accessible from Grafana Dashboard.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://networknt.github.io/light-java/middleware/sanitizer/&#34;&gt;sanitizer&lt;/a&gt; is a
middleware that address cross site scripting concerns. It encodes header and body based on
configuration.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://networknt.github.io/light-java/middleware/correlation/&#34;&gt;correlation&lt;/a&gt; generates
a UUID in the first API/service and pass it to all other APIs/services in the call tree for
tracking purpose.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://networknt.github.io/light-java/middleware/traceability/&#34;&gt;traceability&lt;/a&gt; is an
id passed in from client and will be unique with an application context. The id will be passed
into the backend and return to the consumer for transaction tracing.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://networknt.github.io/light-java/middleware/cors/&#34;&gt;cors&lt;/a&gt; is a module handles
Cross-Origin Resource Sharing (CORS) pre-flight OPTIONS to support single page applications
from another domain to access APIs/services.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://networknt.github.io/light-java/middleware/dump/&#34;&gt;dump&lt;/a&gt; is a full request/response
log handler to dump everything regarding to request and response into log file for developers.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://networknt.github.io/light-java/middleware/limit/&#34;&gt;limit&lt;/a&gt; is a rate limiting handler
to limit number of concurrent requests on the server. Once the limit is reached, subsequent
requests will be queued for later execution. The size of the queue is configurable.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
  </channel>
</rss>